<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/G128.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/G32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/G16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"njughr.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="书山有路勤为径 书单：《SoC设计方法与实现》《芯片验证漫游指南：从系统理论到UVM的验证全视界》《硬件架构的艺术：数字电路的设计方法与技术》《计算机组成与设计：硬件软件接口》《Verilog HDL高级数字设计》《VLSI数字信号处理系统设计与实现》《综合和时序分析的设计约束 Synopsys设计约束（SDC）实用指南》《COMPUTER ARITHMETIC : Algorithms and">
<meta property="og:type" content="article">
<meta property="og:title" content="读书笔记">
<meta property="og:url" content="https://njughr.github.io/2021/11/16/books/index.html">
<meta property="og:site_name" content="GHR&#39;s Blog">
<meta property="og:description" content="书山有路勤为径 书单：《SoC设计方法与实现》《芯片验证漫游指南：从系统理论到UVM的验证全视界》《硬件架构的艺术：数字电路的设计方法与技术》《计算机组成与设计：硬件软件接口》《Verilog HDL高级数字设计》《VLSI数字信号处理系统设计与实现》《综合和时序分析的设计约束 Synopsys设计约束（SDC）实用指南》《COMPUTER ARITHMETIC : Algorithms and">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://njughr.github.io/2021/11/16/books/RTLVeri.svg">
<meta property="og:image" content="https://njughr.github.io/2021/11/16/books/ESL.svg">
<meta property="og:image" content="https://njughr.github.io/2021/11/16/books/liqiu.jpg">
<meta property="article:published_time" content="2021-11-16T11:53:44.000Z">
<meta property="article:modified_time" content="2022-05-12T08:09:52.509Z">
<meta property="article:author" content="Haoran Geng">
<meta property="article:tag" content="IC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://njughr.github.io/2021/11/16/books/RTLVeri.svg">

<link rel="canonical" href="https://njughr.github.io/2021/11/16/books/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>读书笔记 | GHR's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">GHR's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">骐骥一跃，不能十步<br>驽马十驾，功在不舍</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">20</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://njughr.github.io/2021/11/16/books/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cyberavt.jpg">
      <meta itemprop="name" content="Haoran Geng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GHR's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          读书笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-16 19:53:44" itemprop="dateCreated datePublished" datetime="2021-11-16T19:53:44+08:00">2021-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-12 16:09:52" itemprop="dateModified" datetime="2022-05-12T16:09:52+08:00">2022-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>书山有路勤为径</strong></p>
<p><strong>书单</strong>：《SoC设计方法与实现》《芯片验证漫游指南：从系统理论到UVM的验证全视界》《硬件架构的艺术：数字电路的设计方法与技术》《计算机组成与设计：硬件软件接口》《Verilog HDL高级数字设计》《VLSI数字信号处理系统设计与实现》《综合和时序分析的设计约束 Synopsys设计约束（SDC）实用指南》《COMPUTER ARITHMETIC : Algorithms and Hardware Designs》《数字集成电路——电路、系统与设计》《Verilog编程艺术》《昇腾AI处理器架构与编程》</p>
<span id="more"></span>
<h1 id="SoC设计方法"><a href="#SoC设计方法" class="headerlink" title="SoC设计方法"></a>SoC设计方法</h1><p><strong>SoC设计方法与实现</strong> by 郭炜等</p>
<p>资料下载：<a target="_blank" rel="noopener" href="https://www.hxedu.com.cn/hxedu/hg/book/bookInfo.html?code=G0322540">SoC设计方法与实现（第3版）-华信教育资源网</a></p>
<p><strong>为了避免思路的coherence被打断，可以先读完再整理笔记。</strong></p>
<p><strong>1-5</strong>：没啥好说的，序言，SoC的重要性，强调IC的重要性和人才的需求。更多的是在整理单词。SoC的优势：可以实现更复杂的系统，具有较低的设计成本，具有更高的可靠性，缩短产品设计时间，减少产品反复的次数，满足更小尺寸的设计要求，低功耗。</p>
<p><strong>6-10</strong>：SoC面临的挑战：集成密度高导致复杂性增加，时序收敛问题，信号完整性问题，低功耗设计问题，可制造性设计和成品率问题。整体来讲都是一些科普。</p>
<p><strong>11-15</strong>：硬件工程师应仔细理解所谓<strong>系统设计文档</strong>。第二章开始讲SoC设计流程。SoC需要一种软硬件协同设计的方法进行设计，即系统需求说明+高级算法建模与仿真+软硬件划分过程+软硬件同步设计+硬件系统测试。明天看的所谓“基于标准单元的SoC芯片设计流程”可以回答一些很重要的疑惑，需要认真看。</p>
<p><strong>16-20</strong>：IP核是SoC设计的基础。要多写IP核、多整理IP核。整理到ICAIS\codes\GHR_IPcores目录下。<strong>面积，速度，功耗，可测性，可靠性</strong>是衡量芯片成功与否的主要技术指标。基于标准单元的设计流程共有20步。他们是：</p>
<p>硬件设计定义，模块设计及IP复用，顶层模块集成，前仿真，逻辑综合，版图布局规划，电源网络功耗分析，单元布局和优化，DFT插入，时钟树综合，布线设计，功耗分析，信号完整性，优化，寄生参数提取，布局后仿真，ECO修改，后仿真，物理验证，交付芯片制造厂。其中，逻辑综合、DFT插入、寄生参数提取、ECO修改后都需要完成STA，DFT插入、优化、ECO修改后需要进行形式验证。</p>
<p>一般来说IC前端是逻辑设计，IC后端是物理设计，验证工作贯穿前后端，但是功能验证是前端的工作。形式验证+STA是设计的静态验证的两种组成。为了方便测试，逻辑电路插入扫描链，输入输出端口采用边界扫描。明天着重看FPGA。</p>
<p><strong>21-25</strong>：FPGA中的IO是按组分配的，每组可以独立支持不同的标准。DCM由DLL、DFS、DPS和DSS组成。BRAM是FPGA最主要的存储资源。BRAM可以配置为单口RAM，简单双端口RAM，真双口RAM，ROM，FIFO等。FPGA厂商也会提供很多内嵌专用IP单元，软核硬核都有，处理器单元之类的都有，利于SoC设计。FPGA的设计流程为：电路功能设计，设计输入，功能仿真，综合，综合后仿真（<strong>把综合生成的标准延时文件反标注到模型中</strong>），实现与布局布线，时序仿真与验证（<strong>后仿真，将布局布线的延时信息反标注到设计网表中</strong>），板级仿真与验证，芯片编程与调试。</p>
<p><strong>硬核、固核和软核的区别</strong>：硬核，比如PowerPC和ARM。软核，比如Microblaze，Nios等。IP核模块有行为（Behavior）、结构（Structure）和物理（Physical）三级不一样程度的设计，对应描述功能行为的不一样分为三类，即软核（Soft IP Core）、完成结构描述的固核（Firm IP Core）和基于物理描述并通过工艺验证的硬核（Hard IP Core）。 软核一般是HDL文本，也称为虚拟组件VC-Virtual Component。 IP固核的设计程度则是介于软核和硬核之间，除了完成软核全部的设计外，还完成了门级电路综合和时序仿真等设计环节。通常以门级电路网表的形式提供给用户，可以用于FPGA实现。 IP硬核是基于半导体工艺的物理设计，已有固定的拓扑布局和具体工艺，并已通过工艺验证，具备可保证的性能。其提供给用户的形式是电路物理结构掩模版图和全套工艺文件，是能够拿来就用的全套技术。</p>
<p><strong>26-30</strong>：开始讲SoC设计与EDA工具，提到了Vivado High-Level Synthesis，注意ESL设计的建模语言是C/C++，SystemC，System Verilog。软硬件协同验证工具有Mentor的<strong>Seamless</strong>，Carbon Design Systems的<strong>SoC Designer</strong>。Mentor的<strong>Catapult</strong>可以实现C++到RTL的综合。<strong>动态验证就是加外部激励的仿真。</strong></p>
<p><strong>30-35：静态验证不需要激励。电路应首先进行静态验证以纠正一些显然的错误。</strong>静态验证包括形式验证（主流是Equivalence Check和STA。<strong>感觉等效性检查有点像Layout Versus Schematics，可以用来比较RTL和布局布线后得到的网表的功能逻辑是否一致、加入</strong>扫描链**后的逻辑是否还一致，ECO修正前后是否还一致等。更多关于ECO的内容详见IC笔记。STA可以检测：建立/保持时间，最小和最大跳变延时，时钟脉冲宽度和时钟畸变，门级时钟的瞬时脉冲，总线竞争与总线悬浮错误，不受约束的逻辑通道。</p>
<p>综合是非常重要的一步，其作用是<strong>把行为描述转换为实际电路</strong>。综合的任务是基于<strong>电路RTL描述，工艺库，命令及约束</strong>输出门级网表。流程是翻译/展平+优化+映射。</p>
<p>测试和验证的区别：验证对设计负责，检查电路功能，基于事件或时钟驱动；测试对质量负责，检查制造缺陷，基于故障模型。</p>
<p>为了增加可控制性和可观察性，应该使用内部扫描测试设计。<strong>内部扫描测试设计将内部时序存储单元全部串联形成一个长的移位寄存器</strong>。更多关于DFT的内容参见IC笔记。</p>
<p>JTAG技术用于边界扫描测试，即芯片与芯片、模块与模块连接过程中的边界测试。IEEE 1149.1即JTAG标准。</p>
<p><strong>36-41</strong>：布局布线，物理验证（DRC，ERC，LVS） 参数提取主要提取的是寄生RC，如各种寄生电容。有1-D提取，2-D提取，2.5-D提取和在发展中的3-D提取。工具链的完整流程是从RTL到GDSII。GDSII应该就是物理版图文件。</p>
<p><strong>42-45</strong>：开始学习<strong>第四章 SoC系统架构设计</strong>。系统约束主要有总线吞吐率、芯片面积、功耗之类的。明天开始学习总线。</p>
<p><strong>46-49</strong>: AMBA总线包括AHB，ASB，APB，AXI。明天开始学存储器。</p>
<p><strong>50-56</strong>：一级cache为每个核心独享，二三级cache是共享的。今天学习的存储器内容更多的扔到了memory里面。明天开始学多核SoC的系统架构设计。</p>
<p><strong>57-77</strong>：工程伦理+电子信息前沿上课，懒得听，全力推SoC课本。结果醉了，完全看不懂，都是一些宏观方面的描述，抽象层次太高，没有经验实在不知道他在说什么。明天开始学SystemC可能会好一点，细节总是更容易理解。反正今天主要是抄单词吧。</p>
<p><strong>78-84</strong>：开始学SystemC，完全看不懂。前天看的那些模块，端口，接口，通道，今天看的事务级建模，信号，事件，定时，并发，进程，内部信号，内部数据，子模块，构造函数，析构函数，敏感变量，方法进程，线程进程，钟控线程进程，大堆新的数据类型，新类，各种抽象类，基类，语法。。。在下当年上C++就没认真学，现在看SC直接给我整懵了。果断放弃，我不配。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1P54y1z77U?spm_id_from=333.337.search-card.all.click">【数字芯片验证&amp;软硬件协同仿真】SystemC</a></p>
<p><strong>85-108</strong>：看完了SystemC的DMA设计，无时钟版本和有时钟版本，无时钟用SC_THREAD，有时钟用SC_METHOD。看完了整个第5章，感觉毫无收获。确实扯了很多内容，很多流程图，很多模型，但是没什么用。光看不练看不懂。IP验证要验证兼容性、边界验证、随机验证、应用程序验证以及修改了某一部分后重跑所有验证样例的回归验证。硬核需要包括功能模型，时序模型，功耗模型，测试模型，物理模型。</p>
<p><strong>109-114</strong>：编写RTL代码之前的准备，主要就是对项目的概念越清楚越好，与团队多交流，团队风格一致，模块划分清晰，每个模块提供说明，避免粘附逻辑，<strong>尤其避免多个模块的组合逻辑拼在一起就像我之前干的那样，因为DC默认不会跨模块对组合逻辑进行归并优化</strong>，多周期路径和伪路径是非常恶心的东西，提到了时钟分频，门控时钟，门控单元的概念。指出数据传输应在接口建立申请应答机制。时钟生成要单独一个模块。总线接口应单独一个模块。特殊测试应单独一个模块。RTL暂时不需要考虑扫描链问题。外部必须可以控制内部复位，因此可能需要MUX。外部必须可以控制内部时钟，因此可能需要MUX。三态驱动看不懂，说什么必须有可知的输出，多个三态驱动不能同时有效。<strong>特殊的结构单元，如单周期乘法器，串行加法器链，复杂控制逻辑，大指令解码单元可以在RTL中直接调用Synopsis的DesignWare库。</strong> 注意布线阻塞问题，大的拆分成分布式的小的。</p>
<p><strong>什么是门控时钟？</strong> 时钟门控即Clock-Gating，是一种重要的降低功耗手段。</p>
<p><strong>门控时钟的RTL一般怎么写？</strong>：TODO</p>
<p><strong>115-120</strong>:可综合RTL编写指南，很重要。</p>
<p><strong>利用综合进行代码质量检查</strong>：负裕量Negative Slack是什么玩意？</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gaoxcv/article/details/92622900">时序余量（Negative Slack） 和 理论最大频率（Fmax）</a></p>
<p><strong>DesignWare</strong>是Synopsys提供的IP库。用法有Operator Inference运算符推断和Component Instantiation组件实例化，如下</p>
<p><strong>合理猜测在调用IP库的时候注释其实也起到了脚本的作用，而不仅仅被简单忽略掉</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Operator Inference</span></span><br><span class="line"><span class="keyword">module</span> my_adder(a,b,sum)</span><br><span class="line">    <span class="keyword">input</span> a,b,c;</span><br><span class="line">    <span class="keyword">output</span> sum;</span><br><span class="line">    <span class="comment">// synopsys resource r0</span></span><br><span class="line">    <span class="comment">// map_to_module = &quot;DW01_add&quot;</span></span><br><span class="line">    <span class="comment">// implementation = &quot;cla&quot;</span></span><br><span class="line">    <span class="comment">// ops = &quot;al&quot;</span></span><br><span class="line">    <span class="keyword">assign</span> sum = a + b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Component Instantiation</span></span><br><span class="line"><span class="keyword">module</span> my_adder(a,b,sum)</span><br><span class="line">    <span class="keyword">input</span> a,b,ci;</span><br><span class="line">    <span class="keyword">output</span> co,sum;</span><br><span class="line">    <span class="comment">// synopsys dc_script_begin</span></span><br><span class="line">    <span class="comment">// set_implementation cla adder</span></span><br><span class="line">    <span class="comment">// synopsys dc_script_end</span></span><br><span class="line">    DW01_add <span class="variable">#(1) adder(.A(a),.B(b),.CI(ci),.SUM(sum),.CO(co))</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>使用DesignWare需要在综合库即synthetic_library中添加<code>synthetic_library=dw_foudation.sldb</code>，并在DC中执行<code>set synthetic_library dw_foundation.sldb</code>。</p>
<p><strong>同步电路设计及其与异步信号交互的问题</strong></p>
<p>关于亚稳态为什么要用两级触发器做同步器防止亚稳态传播，理论是这样的：数字电路跨时钟域传输控制信号关键不是说能否实时的采到控制电平，而是准确采到电平的变化。数字电路可能认为0.6V是1，0.4V是0，而理想情况下1.5V是1，0V是0。在1.5V下，触发器可以强力的对后级扇出进行充能【充能这个词不免让我想到了海啸防御系统的<strong>猫又</strong>和军用科技的<strong>M-179阿喀琉斯</strong>】，保证多级扇出的每一个后级触发器都知道逻辑是高电平。但是在不保证建立时间的情况下，触发器采到亚稳态电平，其输出可能是0.6V或0.4V，这个电平并不能充分的对后级触发器进行充能，例如0.6V充5个触发器，有可能3个认为是1，而2个认为是0，这就造成不可挽回的亚稳态大面积传播后果。但是如果使用两级触发器级联成的同步器，在前级输出一个亚稳态后，如果后级扇出太多，电容就太大，这样由于RC时间常数问题，0.6这个输出会更难升高，也就是更难驱动一堆触发器，这就造成了扇出的传播。注意实际上后级触发器只care上升沿那个时刻，但是前级触发器的输出充电是取决于扇出的。这也就是说如果用两级触发器级联，后级只有1个触发器，RC小，更容易充电，就不容易造成亚稳态的传播。</p>
<h2 id="工具整理"><a href="#工具整理" class="headerlink" title="工具整理"></a>工具整理</h2><p><strong>动态验证相关工具</strong>：电路级仿真工具，如SPICE，TimeMill，NanoSim。逻辑仿真工具，如VCS，Verilog-XL，NC Verilog，Modelsim。电路级仿真工具用于模拟晶体管级行为特性，用于模拟IC设计。逻辑仿真工具可以仿真行为级、RTL级和门级网表，采用事件驱动或周期驱动方式，用于数字电路设计。基于SPICE的工具有HSPICE，PSPICE，Or CAD， Electronics Workbench。Nanosim和VCS是Synopsis公司开发的。明天开始学静态验证相关工具。</p>
<p><strong>静态验证-形式验证相关工具：</strong>Synopsis的<strong>Formality</strong>，Cadence的<strong>Encounter Conformal Equivalent Checker</strong></p>
<p><strong>静态验证-STA工具</strong>：Synopsis的<strong>Primetime</strong></p>
<p><strong>逻辑综合及综合工具</strong>：Synopsis的<strong>Design Compiler</strong>，即DC，综合工具领域90%的市场份额，1%的使用风险，绝对的垄断。</p>
<p><strong>物理综合工具</strong>：Synopsis的<strong>Physical Compiler</strong></p>
<p><strong>内部扫描测试设计工具</strong>：Synopsis的<strong>DFT Compiler</strong>和Mentor的<strong>DFT Advisor</strong></p>
<p><strong>ATPG工具</strong>：Mentor的<strong>Fastscan</strong>和Synopsis的<strong>TetraMAX</strong>。</p>
<p><strong>BIST工具</strong>：Mentor的<strong>mBISTArchitect</strong>和Synopsis的<strong>SoCBIST</strong></p>
<p><strong>边界扫描测试工具</strong>：Mentor的<strong>BSD Architect</strong>和Synopsis的<strong>BSD Compiler</strong>。</p>
<p><strong>布局布线工具</strong>：Synopsis的<strong>Astro</strong></p>
<p><strong>已经成为工业标准的工具</strong>：Synopsis的STA工具<strong>Prime-time</strong>，晶体管级电路模拟仿真软件<strong>HSPICE</strong>，逻辑综合工具<strong>Design Compiler</strong>，Cadence的全定制芯片流程软件包<strong>ICFB</strong>，Mentor的DRC&amp;LVS工具<strong>Calibre</strong>。</p>
<p><strong>RTL2GDSII工具包</strong>：Synopsis的<strong>Galaxy</strong>平台，Candence的<strong>SoC Encounter</strong>，Magma的<strong>Blaster</strong>。</p>
<p>更多设计工具可以参见《SoC》P39。</p>
<h1 id="芯片验证漫游"><a href="#芯片验证漫游" class="headerlink" title="芯片验证漫游"></a>芯片验证漫游</h1><p><strong>芯片验证漫游指南：从系统理论到UVM的验证全视界</strong> by 刘斌（路桑）</p>
<p><strong>2.1.4节 P21</strong>介绍了语言的抽象级比较。整理如下（从高到低）：</p>
<p><strong>需求级</strong>：MATLAB</p>
<p><strong>结构级</strong>：MATLAB, SystemC</p>
<p><strong>软件级</strong>：MATLAB, SystemC, System Verilog</p>
<p><strong>功能验证级</strong>：SystemC, System Verilog, Vera/e, Verilog, VHDL</p>
<p><strong>测试平台级</strong>：SystemC, System Verilog, Vera/e, Verilog, VHDL</p>
<p><strong>RTL级</strong>：SystemC, System Verilog, Verilog, VHDL</p>
<p><strong>门级</strong>：System Verilog, Verilog, VHDL</p>
<p><strong>晶体管级</strong>：System Verilog, Verilog</p>
<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rouwawa/p/10031833.html">FPGA基础学习(7) — 内部结构之CLB</a></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1712679492810498953&amp;wfr=spider&amp;for=pc">从Intel做了个RISC-V处理器谈起</a>【硬核，软核，Nios】</p>
<p><a target="_blank" rel="noopener" href="http://www.javashuo.com/article/p-dieoztjv-ba.html">软核，硬核、固核的区别！(整理总结)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/441169231">ECO及其流程总结</a></p>
<h1 id="笔记1"><a href="#笔记1" class="headerlink" title="笔记1"></a>笔记1</h1><p><strong>SoC功能验证面临的挑战概述</strong> by GHR</p>
<p>本文基于现有的文献及书籍资料，从较宏观的层面概括性的描述了在片上系统（System on Chip）设计流程中验证（Verification）工作的概念、目的和主要技术，并以功能验证为重点，分析了5种验证技术：基于仿真的RTL验证方法，基于断言的验证方法，基于硬件模拟的验证方法，软硬件协同验证方法，UVM（Universal Verification Methodology）验证方法学各自的优势和所面临的主要挑战。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>片上系统（System-on-a-Chip, 即SoC技术）的出现和发展有两个主要的促成因素[1]，一是集成电路的类型正在向多样化发展，二是芯片集成度越来越高。SoC通过将整个电路系统集成到一个芯片上，可以大大提高产品性能，显著缩小体积，适用于复杂系统，具有更低的设计成本和更高的可靠性，并具有低功耗性能。在SoC芯片高速发展的同时，也带来了一系列问题。制约SoC发展的因素包括设计成本问题、器件设计和验证复杂性大大增加的问题、时序难以收敛的问题、信号完整性不容易达到的问题、低功耗设计问题、可制造性设计问题和良率问题等。这些问题几乎都与SoC验证工作具有强相关关系。SoC功能验证贯穿着整个SoC设计流程，并且由于缺陷修复代价的原因，在设计阶段越早期发现故障，就越能减少修复成本和时间。然而，即使是在最后门级设计网表中发现缺陷，仍然比直接流片的损失小得多，因此设计阶段的每一个流程都需要验证的工作的参与。因此，深入研究贯穿SoC设计始终的验证工作对SoC领域的发展具有重要意义。</p>
<p>验证工作可以分为功能验证、时序验证、形式验证和物理验证。其中，功能验证还可以细分为模块内部功能验证、模块间功能验证、芯片级功能验证和系统应用级功能验证等。验证还具有很多层次，包括模块级验证、子系统级验证、芯片系统级验证、硅后系统级验证[2]。所谓功能验证，指的是验证人员通过各种手段验证原始描述的正确性，验证设计的逻辑功能符合设计规范的要求。时序验证的主要目的则是保证电路时序能够收敛，保证结果的时序符合原始设计规范的性能指标。形式验证指的是从等价性检查或基于数学变换的静态分析等上层抽象层面从理论上对电路功能进行分析验证。物理验证的则是对芯片的物理架构进行最后的检查，验证结果不包含违反物理设计规则的错误。模块内部功能验证是为了保证单个模块的功能正确。模块间功能验证是为了保证各个模块之间的通信正常。芯片级功能验证则是要在顶层（Top-level）进行验证，即将所有模块集成到一起，完成模块集成验证。系统应用级验证则是要尽量模拟实际使用环境，提高验证覆盖率。</p>
<p>目前主要的验证方法有动态仿真、形式验证和硬件加速。此外，虚拟模型平台、电源功耗评估、性能评估等方法也是重要的补充[3]。动态仿真方法包括定向测试、随机测试、参考模型检查、断言检查。静态检查包括语法检查、语义检查、跨时钟域检查和形式检查。为了加速仿真，还可以使用虚拟模型平台的验证和基于FPGA等实际硬件的验证。此外，SoC的效能和性能也需要充分的验证，如电源功耗方面的验证、性能评估等。宏观来讲，造成SoC验证越来越困难的原因来自如下两个问题：</p>
<ul>
<li>系统复杂性的逐渐提高增加了功能验证的难度。</li>
<li>设计层次的更高层抽象增加了功能验证的工作量。</li>
</ul>
<p>在验证工作的难度逐步提升的同时，对验证工作完成质量的要求和验证失败的代价也在不断提升[4-6]。简要来讲，验证工作需要具备五个维度的能力：完备性，即验证足够充分；复用性，即模块之间的相对独立和快速复用；高效性，即用尽可能少的工作量完成验证；高产出，即在同等时间内尽可能多纠正设计缺陷；代码性能，即在保证效率的基础上尽可能增加代码效率和可读性。事实上，如何提高验证工作的完备性和高效性是一个重要且困难的目标，参考文献[7]指出达到验证的完备性所面临的两大主要挑战为：</p>
<ul>
<li>如何穷尽所有可能的情况给设计产生激励。</li>
<li>如何在各种可能的激励情况下判断出不符合硬件描述的行为并报告出来。</li>
</ul>
<p>但是，要达到验证工作所必需的完备性，就不容易达到验证工作所要求的高效性。这两个重要的指标存在矛盾，因此在验证工作中如何找到完备性和高效性的平衡也是重要的课题之一。</p>
<p>在本文中，我们着重分析SoC功能验证工作的概念、目的、现状以及面临的主要挑战。本文第一章为引言，简要介绍了SoC验证的基本概念。第二章为SoC功能验证技术基础，介绍了在SoC功能验证过程中常见的方法学和工具，并基于当前技术条件，给出了每种技术所面临的主要挑战。第三章为总结与展望。</p>
<h2 id="SoC功能验证技术及挑战"><a href="#SoC功能验证技术及挑战" class="headerlink" title="SoC功能验证技术及挑战"></a>SoC功能验证技术及挑战</h2><p>本节将分5个部分介绍SoC功能验证技术以及这些技术所面临的主要挑战：基于仿真的RTL验证方法，基于断言的验证方法，基于硬件模拟的验证方法，软硬件协同验证方法，以及通用验证方法学UVM（Universal Verification Methodology）。我们将首先介绍传统的基于仿真的RTL验证方法，并引入随机测试、激励、覆盖率等验证方面的概念。由于RTL仿真验证方法自身的局限性，我们将进一步介绍基于断言的验证方法，这种方法的目的是在仿真时增加监控，加强仿真过程中的可观测性。传统的基于仿真的RTL验证方法和基于断言的验证方法的速度都不够快，因此我们还将进一步介绍基于硬件模拟验证方法和基于ESL设计的软硬件协同验证方法。最后，我们将介绍UVM验证方法学，UVM是进行高效SoC验证的重要平台，经过多家半导体公司和EDA公司的推动，现已成为了工业界主流。</p>
<h3 id="基于仿真的RTL验证方法"><a href="#基于仿真的RTL验证方法" class="headerlink" title="基于仿真的RTL验证方法"></a>基于仿真的RTL验证方法</h3><p>基于仿真的RTL验证方法是功能验证中最主要的方法，其他的验证方法都是对这种方法的补充。图1给出了这种验证方法的典型架构框图。</p>
<p><img src="/2021/11/16/books/RTLVeri.svg" alt="RTLVeri"></p>
<p>图1可以分为3部分，左侧为激励模型，中间为被验证器件，右侧为检测模型。激励模型用于产生激励向量，该向量是硬件系统的输入。激励分为直接测试激励和随机测试激励。直接测试激励即测试人员定义的特定激励，可以检测测试人员希望检测到的缺陷。随机测试激励则更利于发现测试人员没能想到的缺陷。直接测试激励手段有时也被称为定向测试，随机测试激励手段也被称为随机测试。在决定了测试用例之后，参考的输出一般是由C/C++等高级语言代码实现的模拟系统输出得到[8]。检测模型则包括各种检测系统仿真运行结果的手段，如在终端上显示测试平台的结果，通过波形图验证结果的正确性等。一个重要的验证指标是覆盖率。覆盖率模型由结构覆盖率（Structural Coverage）和功能覆盖率（Functional Coverage）组成，验证的目标是达到覆盖率要求，从而减少器件出错的可能性。</p>
<ul>
<li>作为传统的验证手段，基于RTL的仿真验证面临着3个主要挑战：</li>
<li>SoC设计状态空间巨大，测试向量无法覆盖整个状态空间，因此如何选取测试向量会对验证流程产生重要影响。</li>
<li>在RTL仿真验证发现输出错误后，由于芯片的复杂性，定位到错误发生的源头是很困难的。</li>
</ul>
<p>仿真速度慢。RTL前端仿真和门级后端仿真每秒处理的指令周期只有几十上百个，而一般SoC应用会包含上百万个指令周期，仿真速度会非常慢。事实上，即将介绍的基于断言的验证方法则是在试图克服第一个和第二个困难时提出的，而基于硬件模拟的验证方法和软硬件协同验证方法就是在试图克服第三个困难时提出的。</p>
<h3 id="基于断言的验证方法"><a href="#基于断言的验证方法" class="headerlink" title="基于断言的验证方法"></a>基于断言的验证方法</h3><p>如上文所述，在传统的基于RTL仿真的验证手段中，可观测性和可控制性都不佳。通过外部施加激励观测输出端口的方式可以容易的控制输入信号，但是很难控制设计内部的信号。RTL仿真要发现问题必须满足两个条件，一是激励必须合适从而可以激活错误，二是错误能够以某种预期形式进行输出。如果错误没有在输出表现出来，或错误发生的位置距输出很远，都给错误定位带来了困难。基于断言的验证就是在这种背景下产生的。</p>
<p>所谓基于断言的验证，是指在图1所描述的仿真测试架构的基础上加入断言，包括激励部分的输入断言、接口约束和断言、RTL断言、响应检测部分的断言等。目前被工业界广泛使用的描述断言的语言是SVA（System Verilog Assertion），该语言是System Verilog的组成部分，可以用于描述和控制、时序相关的问题。设置对某种属性的断言的目的是给该属性设立仿真时的检查点，从而随时可以监控该属性是否满足断言所给出的条件，一旦不满足断言就会立即触发错误的产生，也就是说断言出错的位置就是错误出现的具体位置，从而增加了RTL仿真验证过程中的可观测性。这种方式比只验证模块输出的方式要精准高效很多。</p>
<p>基于断言的验证方法相比于传统的基于仿真的RTL验证方法，在定位问题的能力上取得了长足的进步。然而这种验证方法依然面临着一些挑战：</p>
<ul>
<li>基于断言的仿真验证方法基于传统RTL验证方法，因此仿真速度慢，很难对SoC百万个指令周期级的规模进行系统级验证仿真。</li>
<li>由于仿真速度慢，一旦断言设置不合理，修改断言重新仿真的时间代价会很大，而断言设置必须人工完成，这对工程师提出了很高的要求。</li>
</ul>
<h3 id="基于硬件模拟的验证方法"><a href="#基于硬件模拟的验证方法" class="headerlink" title="基于硬件模拟的验证方法"></a>基于硬件模拟的验证方法</h3><p>为了解决传统RTL仿真方法速度慢的问题，有时可以直接将代码移植到某个实际的硬件系统上进行验证，如基于FPGA的系统模拟等。这种方式将RTL代码映射到FPGA，由于代码由实际硬件进行执行，因此速度比使用软件进行仿真硬件行为要快得多[4]。这实际上相当于将仿真进行了硬件加速。随着FPGA设计技术的发展，在FPGA验证过程中也可以引入断言，这就可以将本是黑盒验证的FPGA验证变为了可观测性更强的验证方式。</p>
<p>使用诸如FPGA的实际硬件进行模拟的验证方式在执行代码方面比仿真要快得多。但在实际使用过程中依然有如下挑战：</p>
<ul>
<li>将RTL代码映射到实际硬件架构这一步骤需要很长的运行时间，一旦RTL代码进行修改，迭代的时间周期仍然很长。</li>
<li>对于复杂的SoC，有可能需要多块FPGA协同工作，增加了设计成本。</li>
<li>第三方IP一般不会提供RTL代码而只有行为级描述，因此若使用这些IP就不可能综合到FPGA中，从而限制了这种验证方式的使用。</li>
<li>FPGA的输入输出资源有限，芯片互联的速度也较慢，成为了通用验证中的瓶颈。</li>
<li>虽然有基于断言的验证方式，但是调试手段依然少且慢，不能记录所有层次的信号。</li>
</ul>
<h3 id="软硬件协同验证方法"><a href="#软硬件协同验证方法" class="headerlink" title="软硬件协同验证方法"></a>软硬件协同验证方法</h3><p>在SoC设计中，软硬件协同设计是一种重要的设计方法。因为SoC的含义是片上系统，必然包含硬件和软件两部分，故在进行设计和验证时，必须同时从硬件和软件方面进行考虑。所谓软硬件协同仿真验证，就是要在设计的早期提供可以运行目标软件的硬件仿真模型，这样就可以实现软件和硬件的并行开发，同时及时发现硬件架构初始设计中可能存在的问题，如带宽瓶颈等。如果先设计硬件再设计软件，在硬件设计定型后修改架构是非常耗费时间的。</p>
<p>软硬件协同设计在近年来被逐步采用的一个重要因素是电子系统级设计（ESL，Electronic System Level Design）工具的发展。在软硬件协同仿真验证的过程中，软件将作为硬件设计的验证向量，这样既可以找出硬件当中的问题，同时也能验证软件本身的正确性。ESL给软硬件工程师提供了一个虚拟的硬件原型平台，这样可以同时有利于硬件和软件的开发。ESL设计流程如图2所示。</p>
<p><img src="/2021/11/16/books/ESL.svg" alt="ESL"></p>
<p>ESL设计具有如下几个优点：第一，ESL由于拥有严格的时钟精确执行环境，使得软件开发工作可以和硬件开发工作并行执行。第二，ESL由于偏上层，可以更容易的调整系统架构，增加设计的可配置性，减少架构修改所带来的工作量。第三，ESL验证方法由于抽象级较高，验证速度明显快于传统的RTL方法。</p>
<p>软硬件协同仿真验证方法通过高抽象层次和事务封装手段，降低了对SoC系统进行建模的复杂程度，提高了模拟验证的效率，加快了产品开发进程。然而这一方法作为革新的技术手段，目前依然面临着一些挑战。这些挑战包括：</p>
<ul>
<li>如何划分软硬件更多的依赖于工程师的经验，而软硬件的划分对项目开发起到决定性作用。</li>
<li>ESL设计和验证工作中需要大量用于模拟的功能模块，即系统级IP核，但这些用于新技术的IP核必须有专业的厂商进行提供。</li>
<li>作为新兴技术，软硬件协同设计方法因正在开发，必然会出现不同标准之间的分歧与竞争，影响普及推广。</li>
<li>在使用传统模式的设计体系中，改用新型的软硬件协同仿真验证方法将增加设计风险，因此设计人员不容易改变传统设计观念。</li>
</ul>
<h3 id="UVM验证方法学"><a href="#UVM验证方法学" class="headerlink" title="UVM验证方法学"></a>UVM验证方法学</h3><p>UVM通用验证方法学是多家半导体公司和EDA公司联合推出的验证方法学及标准。UVM吸收了eRM，AVM、VMM和OVM等不同方法学的优点，目的是建立通用的、可重构的验证组件，进而高效的进行SoC功能验证，减少验证的费用，实现跨平台的应用。UVM在数据设计、激励产生、验证平台的创建和运行测试程序、覆盖模型的设计和验证策略、分析调试能力等方面都具有相对成熟的方法，并建立了基于System Verilog语言的库，采用积木式模块和标准接口，保证验证人员可以快速搭建可复用的验证组件和验证环境。</p>
<p>UVM作为标准化的设计验证平台的方法，现已成为工业界主流的验证平台。它面向所有数字设计，涵盖从模块级到芯片级，从ASIC到FPGA，从控制逻辑、数据通路到处理器的全部场景。UVM作为一种方法学，并不需要与特定语言进行绑定，然而System Verilog的面向对象、随机约束、线程通信管理等特性使得这种语言很适合用来实现UVM。在当前的验证潮流中，UVM占据着动态仿真领域的绝对主导地位，但这种主导地位也给UVM在发展过程中增加了挑战，如：</p>
<ul>
<li>UVM作为被广泛使用的通用标准，一旦发现标准中不合理的地方，修改标准既困难，也容易造成兼容性问题。</li>
<li>VMM、OVM、UVM等验证IP之间存在方法学的壁垒，无法整合到一起，使得不同方法学所构建的验证资源无法很好的整合，先前使用其他框架的验证项目难以进行方法迁移。</li>
</ul>
<h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>功能验证在芯片全流程中占据重要位置。本文从宏观层面介绍了现有的主要验证技术，并以功能验证技术为切入点，着重介绍了传统的基于仿真的RTL验证方法、基于断言的验证方法、基于硬件模拟的验证方法、软硬件协同验证方法和UVM验证方法学，并分析了上述方法在当前面临的主要挑战。以上方法的讨论总结在表1中给出。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名称</th>
<th>方法特点</th>
<th>面临的挑战</th>
</tr>
</thead>
<tbody>
<tr>
<td>基于仿真的RTL验证方法</td>
<td>经典的验证策略，仍然是最主要的功能验证方法，通过激励-检测完成验证工作</td>
<td>如何准确选取测试向量以增加验证覆盖率，如何定位到错误发生的准确位置，如何提高仿真速度</td>
</tr>
<tr>
<td>基于断言的验证方法</td>
<td>在基于仿真的RTL方法基础上加入了断言，从而更有利于错误定位</td>
<td>如何准确选取测试向量以增加验证覆盖率，如何设置断言，如何提高仿真速度</td>
</tr>
<tr>
<td>基于硬件模拟的验证方法</td>
<td>使用虚拟硬件平台或FPGA等实物硬件构建RTL映射，从而可以借助硬件加速手段加快验证过程</td>
<td>如何提高将RTL映射为实际硬件的速度，如何应对IP提供商不给出可综合代码的情形，如何增加FPGA调试手段，如何增加FPGA的性能并降低成本</td>
</tr>
<tr>
<td>软硬件协同验证方法</td>
<td>允许提前给出可以运行软件的硬件仿真模型，从而做到硬件、软件并行开发，可以提前根据软件测试结果改进硬件架构，减少架构修改的工作量</td>
<td>如何划分硬件部分和软件部分，用于ESL模拟的IP核的供应问题，作为新兴技术多种标准不统一的问题，如何降低将使用传统模式的项目转换到软硬件协同方式的代价和风险</td>
</tr>
<tr>
<td>UVM验证方法学</td>
<td>综合了先前各种验证方法学的优点，成为了一种跨平台的通用标准化的设计验证平台，占据着动态仿真领域的绝对主导地位</td>
<td>如何减少UVM标准一旦修改所造成的兼容性代价问题，如何将使用其他验证方法学的已有项目与UVM项目整合的问题</td>
</tr>
</tbody>
</table>
</div>
<p>从整体来看，每一种验证方法都有在各自特定领域和场景中的优势，但也同时都面临着各种挑战。所有的验证手段都要努力解决两个核心挑战，一是如何保证覆盖率，在越来越庞大的状态空间中找到完备性和高效性的平衡；二是在错误出现后，如何精准的定位到错误来源并予以修正。传统的RTL仿真方法在应付较小规模的硬件时得心应手，但是在硬件复杂度提高后如何定位问题的所在便成为了一个明显的短板。为了解决这一挑战，基于断言的验证方法被提出，通过在仿真全流程中增加断言，提高了仿真的可观测性，让错误不至于传递到多级之后，便于错误的定位。然而基于断言的验证手段本质上仍然是传统的RTL仿真，因此仍然具有仿真速度不够的劣势。随着SoC的硬件复杂度越来越高，集成度突破10亿门，对传统的动态仿真方法提出了严峻的挑战。为了提高仿真的速度，基于硬件模拟的验证方法得到重视。无论是通过虚拟硬件平台对RTL代码进行硬件加速实现，还是将RTL转换为实际电路架构烧录到FPGA当中进行硬件加速，其目的都是为了避免使用CPU仿真硬件带来的速度缓慢问题。然而这些硬件加速方法不可避免的受到IP核不开源的影响，限制了其使用场景。此外，即使可以使用硬件加速方法，将RTL映射到硬件的代价也较高，迭代周期依然缓慢，且FPGA本身的资源限制也制约着大型SoC设计的硬件加速仿真工作的完成。项目进度的不断压缩，时间要求的不断收紧，除了促进硬件加速方法的使用外，同时还促进了软硬件协同设计方法的普及。ESL设计工具的发展，使得软件和硬件的并行开发成为可能。但与所有新兴技术一样，基于软硬件协同验证的体系仍然存在各种标准兼容性不佳、从传统方法改进到新方法会增加额外风险等问题。</p>
<p>在动态仿真领域，UVM是绝对的主导，它整合了三大EDA厂商传统的验证方法学，成为了一个统一的跨平台的架构，是的语言和方法学不再局限于特定的工具，用户不再局限于特定的仿真器。但UVM作为通用标准，必然面临着随着时代发展标准需要进行修改、版本更新的问题，新版本对老版本的兼容性、陈旧用法的注毁所带来的影响有时会限制UVM标准的前进。同时，UVM作为一种相对较新的方法，先前使用eRM、AVM、OVM等其他验证平台的项目想迁移到UVM方法需要付出额外的工作量，而且如果不迁移就无法享受到UVM带来的便利。虽然诸如UVM-ML[11]和XVM等新方法一定程度上实现了OVM和UVM的混合仿真，但这些方法仍然更大程度上处在实验性阶段，没有得到广泛普及。</p>
<h1 id="Refs-1"><a href="#Refs-1" class="headerlink" title="Refs"></a>Refs</h1><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/388592087/answer/2264868996">为什么要多读书少上网？</a>【<strong>这里面答主说的很有道理。网上的信息基本上是零门槛，难以鉴别，需要自行过滤，可以说是沙里淘金。但是出书的门槛较高，因此会帮助省去很多自行过滤的精力，读到真正有价值的付费内容。其实鉴别知识价值的很好的方法就是看作者敢不敢实名，不敢实名的基本就可以当做娱乐了。</strong>】</p>
<hr>
<p><img src="/2021/11/16/books/liqiu.jpg" alt="立秋"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Haoran Geng
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://njughr.github.io/2021/11/16/books/" title="读书笔记">https://njughr.github.io/2021/11/16/books/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/IC/" rel="tag"># IC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/31/english/" rel="prev" title="学洋文">
      <i class="fa fa-chevron-left"></i> 学洋文
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/07/news/" rel="next" title="时事新闻">
      时事新闻 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SoC%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">SoC设计方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">工具整理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8A%AF%E7%89%87%E9%AA%8C%E8%AF%81%E6%BC%AB%E6%B8%B8"><span class="nav-number">2.</span> <span class="nav-text">芯片验证漫游</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Refs"><span class="nav-number">2.1.</span> <span class="nav-text">Refs</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%94%E8%AE%B01"><span class="nav-number">3.</span> <span class="nav-text">笔记1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">3.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SoC%E5%8A%9F%E8%83%BD%E9%AA%8C%E8%AF%81%E6%8A%80%E6%9C%AF%E5%8F%8A%E6%8C%91%E6%88%98"><span class="nav-number">3.2.</span> <span class="nav-text">SoC功能验证技术及挑战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BB%BF%E7%9C%9F%E7%9A%84RTL%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.</span> <span class="nav-text">基于仿真的RTL验证方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%96%AD%E8%A8%80%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">基于断言的验证方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%A1%AC%E4%BB%B6%E6%A8%A1%E6%8B%9F%E7%9A%84%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.3.</span> <span class="nav-text">基于硬件模拟的验证方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E7%A1%AC%E4%BB%B6%E5%8D%8F%E5%90%8C%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.4.</span> <span class="nav-text">软硬件协同验证方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UVM%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E5%AD%A6"><span class="nav-number">3.2.5.</span> <span class="nav-text">UVM验证方法学</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="nav-number">3.3.</span> <span class="nav-text">总结与展望</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Refs-1"><span class="nav-number">4.</span> <span class="nav-text">Refs</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Haoran Geng"
      src="/images/cyberavt.jpg">
  <p class="site-author-name" itemprop="name">Haoran Geng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/njughr" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;njughr" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:syhaoran@gmail.com" title="E-Mail → mailto:syhaoran@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1444528490&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Haoran Geng</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script color='105,7,90' opacity='0.6' zIndex='-1' count='100' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
