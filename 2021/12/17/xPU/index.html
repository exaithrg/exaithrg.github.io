<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/G128.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/G32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/G16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"njughr.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ABBREVIATIONSTRV： liangkangnan巨佬的tinyriscv CSAPP： Computer Systems: A Programmer’s Perspective 深入理解计算机系统 CODHSI： Computer Organization and Design: The Hardware&#x2F;Software Interface 计算机组成与设计 硬件&#x2F;软件接口 by D">
<meta property="og:type" content="article">
<meta property="og:title" content="xPU学习">
<meta property="og:url" content="https://njughr.github.io/2021/12/17/xPU/index.html">
<meta property="og:site_name" content="GHR&#39;s Blog">
<meta property="og:description" content="ABBREVIATIONSTRV： liangkangnan巨佬的tinyriscv CSAPP： Computer Systems: A Programmer’s Perspective 深入理解计算机系统 CODHSI： Computer Organization and Design: The Hardware&#x2F;Software Interface 计算机组成与设计 硬件&#x2F;软件接口 by D">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://njughr.github.io/2021/12/17/xPU/TRV.jpg">
<meta property="og:image" content="https://njughr.github.io/2021/12/17/xPU/Matrix_Z.png">
<meta property="og:image" content="https://njughr.github.io/2021/12/17/xPU/qingming.jpg">
<meta property="article:published_time" content="2021-12-17T09:39:52.000Z">
<meta property="article:modified_time" content="2022-01-05T12:38:22.598Z">
<meta property="article:author" content="Haoran Geng">
<meta property="article:tag" content="IC">
<meta property="article:tag" content="CS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://njughr.github.io/2021/12/17/xPU/TRV.jpg">

<link rel="canonical" href="https://njughr.github.io/2021/12/17/xPU/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>xPU学习 | GHR's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">GHR's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">骐骥一跃，不能十步<br>驽马十驾，功在不舍</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">18</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://njughr.github.io/2021/12/17/xPU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/paperboat.jpg">
      <meta itemprop="name" content="Haoran Geng">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="GHR's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          xPU学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-17 17:39:52" itemprop="dateCreated datePublished" datetime="2021-12-17T17:39:52+08:00">2021-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 20:38:22" itemprop="dateModified" datetime="2022-01-05T20:38:22+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="ABBREVIATIONS"><a href="#ABBREVIATIONS" class="headerlink" title="ABBREVIATIONS"></a>ABBREVIATIONS</h1><p>TRV： liangkangnan巨佬的tinyriscv</p>
<p>CSAPP： Computer Systems: A Programmer’s Perspective 深入理解计算机系统</p>
<p>CODHSI： Computer Organization and Design: The Hardware/Software Interface 计算机组成与设计 硬件/软件接口 by <strong>David A. Patterson</strong> and <strong>John L. Hennessy</strong></p>
<p>CAQA: Computer Architecture: A Quantitative Approach 计算机体系结构 量化研究方法 by <strong>John L. Hennessy</strong> and <strong>David A. Patterson</strong></p>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>CPU: Central Processing Unit</p>
<p>目标是设计一个具有现代CPU一切重要特性的原型机，并将其在FPGA和MC上验证出来。基于RISC-V的精神，项目将在完成后开源。</p>
<p>目标特性包括：</p>
<p>Multiple-Issue, Out-of-order Execution, Out-of-order pipeline, Superscalar, Dynamic Branch Predictor, Load-store Queue, Non-blocking Cache Controller, Associative Cache, Hardware Prefetching, Simultaneous Multithreading.</p>
<p>多发射，乱序执行，乱序流水线，超标量，动态分支预测，加载存储队列，非阻塞缓存，相联缓存，缓存预取，并发多线程</p>
<p>这些目标特性基于一门UMich的硬核课程。在后期逐步搞懂后我将慢慢增补上述列表。</p>
<span id="more"></span>
<p>详细要求：</p>
<p>实现一个32位冯诺依曼架构CPU及必要外设，可以运行简单的程序（例如打印Hello World）。至少具备基础的MIPS五级流水线，将IF ID EX MEM WB隔开，分析各级时延，逐步进行优化。</p>
<h2 id="RISC-V收集"><a href="#RISC-V收集" class="headerlink" title="RISC-V收集"></a>RISC-V收集</h2><p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1664724825695807851&amp;wfr=spider&amp;for=pc">简评几款开源RISC-V处理器</a>【垃圾百家号盗人文章】</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/phpero/article/details/105699890">原链接</a></p>
<p><strong>Rocket，BOOM</strong></p>
<p>Rocket Chip github：<a target="_blank" rel="noopener" href="https://github.com/chipsalliance/rocket-chip">https://github.com/chipsalliance/rocket-chip</a></p>
<p>BOOM github: <a target="_blank" rel="noopener" href="https://github.com/riscv-boom/riscv-boom">https://github.com/riscv-boom/riscv-boom</a></p>
<p>一句话总结：Berkeley纯正血统，但欲学本core，必先入Chisel之坑。</p>
<p><strong>Hammingbird E203</strong></p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/SI-RISCV/e200_opensource">https://github.com/SI-RISCV/e200_opensource</a></p>
<p>一句话点评：初学者学习RISC-V处理器设计首选。</p>
<p><strong>Ibex</strong></p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/lowRISC/ibex">https://github.com/lowRISC/ibex</a></p>
<p>文档：<a target="_blank" rel="noopener" href="https://ibex-core.readthedocs.io/en/latest/introduction.html">https://ibex-core.readthedocs.io/en/latest/introduction.html</a> </p>
<p>一句话点评：啥都别说了，这么好的东西还不赶紧盘它？</p>
<p><strong>VexRiscv</strong></p>
<p>github：<a target="_blank" rel="noopener" href="https://github.com/SpinalHDL/VexRiscv">https://github.com/SpinalHDL/VexRiscv</a></p>
<p>一句话点评：佳作，SpinalHDL代表作，需入SpinalHDL的坑。</p>
<p><strong>SweRV EH1</strong></p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/chipsalliance/Cores-SweRV">https://github.com/chipsalliance/Cores-SweRV</a></p>
<p>一句话点评：大厂出品，进阶学习佳作。</p>
<p><strong>无剑</strong></p>
<p>github: <a target="_blank" rel="noopener" href="https://github.com/T-head-Semi/wujian100_open">https://github.com/T-head-Semi/wujian100_open</a></p>
<h2 id="课程CPU作业"><a href="#课程CPU作业" class="headerlink" title="课程CPU作业"></a>课程CPU作业</h2><p>参见projects/mccpu/ICCPU_Homework</p>
<p>架构如下：</p>
<h2 id="Ibex"><a href="#Ibex" class="headerlink" title="Ibex"></a>Ibex</h2><p>github: <a target="_blank" rel="noopener" href="https://github.com/lowRISC/ibex">https://github.com/lowRISC/ibex</a></p>
<p>文档：<a target="_blank" rel="noopener" href="https://ibex-core.readthedocs.io/en/latest/introduction.html">https://ibex-core.readthedocs.io/en/latest/introduction.html</a> </p>
<h2 id="从零开始写RISC-V处理器"><a href="#从零开始写RISC-V处理器" class="headerlink" title="从零开始写RISC-V处理器"></a>从零开始写RISC-V处理器</h2><p><a target="_blank" rel="noopener" href="https://gitee.com/liangkangnan/tinyriscv">tinyriscv gitee</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/njughr/tinyriscv">tinyriscv forked by liangkangnan</a></p>
<p><a target="_blank" rel="noopener" href="https://liangkangnan.gitee.io/2020/04/29/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99RISC-V%E5%A4%84%E7%90%86%E5%99%A8/">从零开始写RISC-V处理器</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aT4y197su?spm_id_from=333.999.0.0">B站视频教程</a></p>
<p>tinyriscv是一个32位处理器，采用三级流水线，即取指、译码和执行，设计的目标就是要对标ARM的Cortex-M3系列处理器。为了描述方便，下文中将tinyriscv简称为TRV。</p>
<p>不知道有没有考虑转发问题。</p>
<p>他们的代码风格很不错，学习。例如</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">    c &lt;= b;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    c &lt;= d;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (a)</span><br><span class="line">	c: <span class="keyword">begin</span></span><br><span class="line">		e = g;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">		b = t;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<h3 id="always语句"><a href="#always语句" class="headerlink" title="always语句"></a>always语句</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    a &lt;= b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>=、==、&lt;=、&gt;=、+、-、*、/、@等符号左右各有一个空格。</p>
<p>,和:符号后面有一个空格。</p>
<p>对于模块的输入信号，不省略wire关键字。</p>
<p>每个文件的最后留一行空行。</p>
<p>if、case、always后面都有一个空格。</p>
<h3 id="硬件架构"><a href="#硬件架构" class="headerlink" title="硬件架构"></a>硬件架构</h3><p><img src="/2021/12/17/xPU/TRV.jpg" alt="TRV"></p>
<p>很赞成作者认为这是一个SOC的观点。事实上CPU核心不需要做这么多事情，但是没有其他元件，core毫无用处。</p>
<p>tinyriscv SOC输入输出信号有两部分，一部分是系统时钟clk和复位信号rst，另一部分是JTAG调试信号，TCK、TMS、TDI和TDO。</p>
<p>pc计数器的核心是<code>pc_o &lt;= pc_0 + 4&#39;h4</code>，即<strong>TRV的取值地址是4字节对齐的，每条指令32位</strong>。</p>
<h3 id="regs-v"><a href="#regs-v" class="headerlink" title="regs.v"></a>regs.v</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读寄存器1</span></span><br><span class="line"><span class="keyword">always</span> @ (*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst == <span class="meta">`RstEnable) begin</span></span><br><span class="line">        rdata1_o = <span class="meta">`ZeroWord;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (raddr1_i == <span class="meta">`RegNumLog2&#x27;h0) begin</span></span><br><span class="line">        rdata1_o = <span class="meta">`ZeroWord;</span></span><br><span class="line">    <span class="comment">// 如果读地址等于写地址，并且正在写操作，则直接返回写数据</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (raddr1_i == waddr_i &amp;&amp; we_i == <span class="meta">`WriteEnable) begin</span></span><br><span class="line">        rdata1_o = wdata_i;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        rdata1_o = regs[raddr1_i];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>第5行，如果是读寄存器0(x0)，那么直接返回0就可以了。</p>
<p>第8行，这涉及到数据相关问题。由于流水线的原因，当前指令处于EX（执行阶段）的时候，下一条指令则处于ID（译码阶段）。由于执行阶段不会写寄存器，而是在下一个时钟到来时才会进行寄存器写操作，如果译码阶段的指令需要上一条指令的结果，那么此时读到的寄存器的值是错误的。比如下面这两条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add x1, x2, x3</span><br><span class="line">add x4, x1, x5</span><br></pre></td></tr></table></figure>
<p><strong>这两条指令的含义是：x1 = x2 + x3，紧接着x4 = x1 + x5，因此不能简单的pipeline否则x1数据不能及时更新。</strong></p>
<p>第二条指令依赖于第一条指令的结果。为了解决这个数据相关的问题就有了第8~9行的操作，即如果读寄存器等于写寄存器，则直接将要写的值返回给读操作。这实际上是一种简单的流水线转发技术，参见<strong>CAQA</strong>的<code>附录C 流水线：基础与中级概念</code>中转发技术的部分。</p>
<blockquote>
<p>(1). 来自EX/MEM和MEM/WB流水线寄存器的ALU结果总是被反馈回ALU的输入端；</p>
<p>(2). 如果转发硬件检测到前一个ALU操作已经对当前ALU操作的源寄存器进行了写入操作，则控制逻辑选择转发结果作为ALU输入，而不是选择从寄存器堆中读取的值。</p>
</blockquote>
<p>上述说明是针对RISC经典五级流水线说的。TRV是三级流水线。但是在转发这个概念上，两者的目的是一致的。</p>
<p>关于汇编语言的入门，计算机系学ICS-PA之前的暑期小学期里搞过一个汇编入门的PPT，可以参见<code>D:\ICAIS\projects\mccpu\ICS-PA</code>中的相关内容。</p>
<p>第11行，如果没有数据相关，则返回要读的寄存器的值。</p>
<p>所谓数据相关其实是翻译问题。在<strong>CAQA</strong> P461上指出流水线共有三类冒险：</p>
<blockquote>
<p><strong>结构冒险</strong>：在重叠执行模式下，如果硬件无法同时支持指令的所有可能组合方式，就会出现资源冲突，从而导致结构冒险。</p>
<p><strong>数据冒险</strong>：根据流水线中的指令重叠，指令之间存在先后顺序，如果一条指令取决于先前指令的结果，就有可能导致数据冒险。</p>
<p><strong>控制冒险</strong>：分支指令及其他改变程序计数器的指令实现流水化时可能导致控制冒险。</p>
</blockquote>
<p>这三种冒险有时候也被称为三种相关，即结构相关、数据相关和控制相关。</p>
<p>克服这三种冒险的方法，详见本文另一个二级标题。</p>
<h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><p><strong>目前tinyriscv所有外设(包括rom和ram)、寄存器的读取都是与时钟无关的，或者说所有外设、寄存器的读取采用的是组合逻辑的方式</strong>。这一点非常重要！</p>
<p>（为什么要这样设计呢？ROM和RAM怎么能和时钟无关呢？）</p>
<p>tinyriscv并没有具体的取指模块和代码。PC寄存器模块的输出pc_o会连接到外设rom模块的地址输入，又由于rom的读取是组合逻辑，因此每一个时钟上升沿到来之前(时序是满足要求的)，从rom输出的指令已经稳定在if_id模块的输入，当时钟上升沿到来时指令就会输出到id模块。</p>
<p>取到的指令和指令地址会输入到if_id模块(if_id.v)，if_id模块是一个时序电路，作用是将输入的信号打一拍后再输出到译码(id.v)模块。</p>
<h3 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h3><p>译码(id)模块是一个纯组合逻辑电路，主要作用有以下几点：</p>
<p>1.根据指令内容，解析出当前具体是哪一条指令(比如add指令)。</p>
<p>2.根据具体的指令，确定当前指令涉及的寄存器。比如读寄存器是一个还是两个，是否需要写寄存器以及写哪一个寄存器。</p>
<p>3.访问通用寄存器，得到要读的寄存器的值。</p>
<h3 id="EX"><a href="#EX" class="headerlink" title="EX"></a>EX</h3><p>执行(ex)模块是一个纯组合逻辑电路，主要作用有以下几点：</p>
<p>1.根据当前是什么指令执行对应的操作，比如add指令，则将寄存器1的值和寄存器2的值相加。</p>
<p>2.如果是内存加载指令，则读取对应地址的内存数据。</p>
<p>3.如果是跳转指令，则发出跳转信号。</p>
<p>下面以beq指令说明跳转指令的执行。beq指令的作用就是当寄存器1的值和寄存器2的值相等时发生跳转，跳转的目的地址为当前指令的地址加上符号扩展的imm的值。</p>
<blockquote>
<p><strong>符号扩展</strong></p>
<p>MIPS32 指令集架构中，经常会有指令需要将其中的立即数进行符号扩展，或者无符号扩展，一般都是都是将n位立即数扩展为32位。</p>
<ol>
<li>无符号扩展：直接将扩展后的数据的高(32-n)位置为0。</li>
<li>符号扩展：将扩展后的数据的高(32-n)位置为立即数的最高位。</li>
</ol>
</blockquote>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">`INST_TYPE_B</span>: <span class="keyword">begin</span></span><br><span class="line">    case (funct3)</span><br><span class="line">        <span class="type">`INST_BEQ</span>: <span class="keyword">begin</span></span><br><span class="line">            hold_flag = <span class="type">`HoldDisable</span>;</span><br><span class="line">            mem_wdata_o = <span class="type">`ZeroWord</span>;</span><br><span class="line">            mem_raddr_o = <span class="type">`ZeroWord</span>;</span><br><span class="line">            mem_waddr_o = <span class="type">`ZeroWord</span>;</span><br><span class="line">            mem_we = <span class="type">`WriteDisable</span>;</span><br><span class="line">            reg_wdata = <span class="type">`ZeroWord</span>;</span><br><span class="line">            <span class="keyword">if</span> (reg1_rdata_i == reg2_rdata_i) <span class="keyword">begin</span></span><br><span class="line">                jump_flag = <span class="type">`JumpEnable</span>;</span><br><span class="line">                jump_addr = inst_addr_i + &#123;&#123;<span class="number">20</span>&#123;inst_i[<span class="number">31</span>]&#125;&#125;, inst_i[<span class="number">7</span>], inst_i[<span class="number">30</span>:<span class="number">25</span>], inst_i[<span class="number">11</span>:<span class="number">8</span>], <span class="number">1</span><span class="symbol">&#x27;b0</span>&#125;;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                jump_flag = <span class="type">`JumpDisable</span>;</span><br><span class="line">                jump_addr = <span class="type">`ZeroWord</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>第2~4行，译码出beq指令。</p>
<p>第5~10行，没有涉及的信号置为默认值。</p>
<p>第11行，判断寄存器1的值是否等于寄存器2的值。</p>
<p>第12行，跳转使能，即发生跳转。</p>
<p>第13行，计算出跳转的目的地址。</p>
<p>第15、16行，不发生跳转。</p>
<h3 id="MEM"><a href="#MEM" class="headerlink" title="MEM"></a>MEM</h3><p>MEM即访存操作。由于tinyriscv只有三级流水线，因此没有访存这个阶段，访存的操作放在了执行模块中。具体是这样的，在译码阶段如果识别出是内存访问指令(lb、lh、lw、lbu、lhu、sb、sh、sw)，则向总线发出内存访问请求。</p>
<p>为什么在取指阶段发出内存访问请求？这跟总线的设计是相关的，这里先不具体介绍总线的设计，只需要知道<strong>如果需要访问内存，则需要提前一个时钟向总线发出请求</strong>。</p>
<p><strong>在译码阶段向总线发出内存访问请求后，在执行阶段就会得到对应的内存数据</strong>。</p>
<p>下面看执行阶段的内存加载操作，以lb指令为例，lb指令的作用是访问内存中的某一个字节，代码(位于ex.v)如下：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml">`INST_TYPE_L: begin</span></span><br><span class="line"><span class="xml">	case (funct3)</span></span><br><span class="line"><span class="xml">		`INST_LB: begin</span></span><br><span class="line"><span class="xml">        	jump_flag = `JumpDisable;</span></span><br><span class="line"><span class="xml">        	hold_flag = `HoldDisable;</span></span><br><span class="line"><span class="xml">        	jump_addr = `ZeroWord;</span></span><br><span class="line"><span class="xml">        	mem_wdata_o = `ZeroWord;</span></span><br><span class="line"><span class="xml">        	mem_waddr_o = `ZeroWord;</span></span><br><span class="line"><span class="xml">            mem_we = `WriteDisable;</span></span><br><span class="line"><span class="xml">            mem_raddr_o = reg1_rdata_i + </span><span class="template-variable">&#123;&#123;<span class="name">20</span>&#123;inst_i[31]&#125;&#125;</span><span class="xml">, inst_i[31:20]&#125;;</span></span><br><span class="line"><span class="xml">            case (mem_raddr_index)</span></span><br><span class="line"><span class="xml">            	2&#x27;b00: begin</span></span><br><span class="line"><span class="xml">                	reg_wdata = </span><span class="template-variable">&#123;&#123;<span class="name">24</span>&#123;mem_rdata_i[7]&#125;&#125;</span><span class="xml">, mem_rdata_i[7:0]&#125;;</span></span><br><span class="line"><span class="xml">               	end</span></span><br><span class="line"><span class="xml">                2&#x27;b01: begin</span></span><br><span class="line"><span class="xml">                	reg_wdata = </span><span class="template-variable">&#123;&#123;<span class="name">24</span>&#123;mem_rdata_i[15]&#125;&#125;</span><span class="xml">, mem_rdata_i[15:8]&#125;;</span></span><br><span class="line"><span class="xml">               	end</span></span><br><span class="line"><span class="xml">                2&#x27;b10: begin</span></span><br><span class="line"><span class="xml">                  	reg_wdata = </span><span class="template-variable">&#123;&#123;<span class="name">24</span>&#123;mem_rdata_i[23]&#125;&#125;</span><span class="xml">, mem_rdata_i[23:16]&#125;;</span></span><br><span class="line"><span class="xml">              	end</span></span><br><span class="line"><span class="xml">              	default: begin</span></span><br><span class="line"><span class="xml">                  	reg_wdata = </span><span class="template-variable">&#123;&#123;<span class="name">24</span>&#123;mem_rdata_i[31]&#125;&#125;</span><span class="xml">, mem_rdata_i[31:24]&#125;;</span></span><br><span class="line"><span class="xml">               	end</span></span><br><span class="line"><span class="xml">			endcase</span></span><br><span class="line"><span class="xml">		end</span></span><br><span class="line"><span class="xml">...</span></span><br></pre></td></tr></table></figure>
<p>这里注意大括号的使用，利用复制20遍inst_i[31]实现立即数的符号扩展。指令是32位的，所以立即数是12位的。</p>
<blockquote>
<p>｛｝的基本使用是两个，一个是拼接，一个是复制，下面列举了几种常见用法。</p>
<p>基本用法<br>{ }表示拼接，{第一位，第二位…}；<br>{x{ }}表示复制x遍，{4{a}}等同于{a,a,a,a};<br>所以{13{1‘b1}}就表示将13个1拼接起来，即13’b1111111111111。</p>
</blockquote>
<p>第2~4行，译码出lb指令。</p>
<p>第5~10行，将没有涉及的信号置为默认值。</p>
<p>第11行，得到访存的地址。</p>
<p>第12行，由于访问内存的地址必须是4字节对齐的，因此这里的mem_raddr_index的含义就是32位内存数据(4个字节)中的哪一个字节，2’b00表示第0个字节，即最低字节，2’b01表示第1个字节，2’b10表示第2个字节，2’b11表示第3个字节，即最高字节。</p>
<p>第14、17、20、23行，写寄存器数据。</p>
<p>关于大端和小端问题和访存对齐问题，摘录一道来自<strong>CAQA</strong>的课后习题：</p>
<blockquote>
<p>附录A.22</p>
<p>一数值用十六进制数字434F 4D50 5554 4552表示，将其存储在64位对齐双字中。</p>
<p>a. 大端存储时要存储的字符串是？</p>
<p>b. 小端存储时要存储的字符串是？</p>
<p>c. 大端存储时，可以从给定64位双字中读取的所有非对齐2字节字的值是？</p>
<p>d. 小端存储时，可以从给定64位双字中读取的所有非对齐4字节字的值是？</p>
<p>答：</p>
<p>a. 大端存储</p>
<p>​    低地址                高地址</p>
<p>​    434F 4D50 5554 4552</p>
<p>​    CO MP UT ER</p>
<p>b.小端存储</p>
<p>​    低地址                高地址</p>
<p>​    5245 5455 504D 4F43</p>
<p>​    RE TU PM OC</p>
<p>c. 4F4D 5055 5445 (?)</p>
<p>d. 45545550 5455504D 55504D4F (?)</p>
</blockquote>
<p>再摘录一下ITMB SPARC应对小端存储的策略。寄存器配置详见<code>KFBD_BM3823AMCCRH产品使用手册_20200907（公开）_343</code>的附录3，这里为了描述方便，以GPIO 控制为例。</p>
<p>为了控制3823的GPIO，需要配置两个寄存器：GPIO 输入输出数据寄存器（0x81000400）和GPIO 输入输出方向控制寄存器（0x81000408），这两个寄存器都可以保存32bit。</p>
<p>寄存器地址应该是每个地址对应一个32bit存储空间吧？（大概率不是的，详细见下）</p>
<p>手册提到1GB（0x4000-0000 – 0x7FFF-FFFF）</p>
<p>也就是0x3FFF-FFFF，这个值是1073741823，</p>
<p>1GB=2\^30B或者1000\^3B，即1,073,741,824B或1,000,000,000B，这里明显指的是前者，因此是1GiB。</p>
<p>存储位宽是8bit，一个地址对应8bit</p>
<p><strong>因此按照相似的理论（全是推测），寄存器地址可能也是一个地址对应一个8bit，则为了存储32bit，必须至少是0400 0401 0402 0403四个地址才够。这也印证了寄存器地址一直是0 4 8 C 0 4 8 C排布的特点。</strong></p>
<p>下面继续关于GPIO寄存器大小端存储的问题。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span><span class="number">31</span>___27___23___19___15___11___7____3___</span><br><span class="line"><span class="regexp">//</span><span class="number">0000</span>_0000_0000_0000_0000_0000_0000_0000</span><br></pre></td></tr></table></figure>
<p>部分gpio寄存器定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* part 6 gpio registers */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lregs_gpio</span>&#123;</span>             <span class="comment">//address = 0x81000400</span></span><br><span class="line">	<span class="comment">//GPIO 输入输出数据寄存器</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> piodata;       <span class="comment">/* 0x400 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dummy1;</span><br><span class="line">    <span class="comment">//GPIO 输入输出方向控制寄存器</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> piodir;       </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dummy2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//GPIO 输入滤波分频与中断模式寄存器</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> pioscaler;      <span class="comment">/* 0x410 */</span></span><br><span class="line">    <span class="comment">//GPIO 输入滤波时钟使能寄存器</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> pioscl_clken;</span><br><span class="line">    <span class="comment">//GPIO 中断寄存器</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> pioirq;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dummy3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果希望配置GPIO4和5输出高电平：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lregs_gpio</span>-&gt;piodir = <span class="number">0</span>x<span class="number">0000</span>AA<span class="number">30</span>		// GPIO<span class="number">4</span>和<span class="number">5</span>设为输出</span><br><span class="line"><span class="attribute">lregs_gpio</span>-&gt;piodata = <span class="number">0</span>x<span class="number">00000010</span>	// GPIO<span class="number">4</span>打高</span><br><span class="line"><span class="attribute">lregs_gpio</span>-&gt;piodata = <span class="number">0</span>x<span class="number">00000020</span>	// GPIO<span class="number">5</span>打高</span><br><span class="line"><span class="attribute">lregs_gpio</span>-&gt;piodata = <span class="number">0</span>x<span class="number">00000000</span>	// 清空</span><br></pre></td></tr></table></figure>
<p>这个就不需要reverse？？？？</p>
<p>值得注意的的是reverse操作仅仅出现在了rx_mac_desc_ptr上，单个的寄存器配置不需要reverse</p>
<p><code>volatile struct rx_desc *rx_mac_desc_ptr[RX_DESC_NUM]</code></p>
<p>rx_desc的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span>&#123;</span>						<span class="comment">//没有固定地址，自定义</span></span><br><span class="line">		<span class="comment">// 接收描述符0，包括各种配置 298</span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> status;</span><br><span class="line">		<span class="comment">// 接收描述符1，包括RBS2 RBS1 300</span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> count;		<span class="comment">//+0x04</span></span><br><span class="line">		<span class="comment">//接收描述符2，B1AP 301</span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> buf1_addr;	<span class="comment">//+0x08</span></span><br><span class="line">		<span class="comment">//接收描述符3，B2AP(NDA) 301</span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> buf2_addr;	<span class="comment">//+0x0C</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//接收描述符4，保留</span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> extstatus;	<span class="comment">//+0x10</span></span><br><span class="line">		<span class="comment">//接收描述符5，保留</span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dummy1;		<span class="comment">//+0x14</span></span><br><span class="line">		<span class="comment">//接收描述符6，保留</span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> retimestamplo;	<span class="comment">//+0x18</span></span><br><span class="line">		<span class="comment">//接收描述符7，保留</span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> retimestamphi;	<span class="comment">//+0x1C</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>举个栗子</p>
<p>需要两个reverse函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Reverse32(in) ( (in &amp; 0x000000ff) &lt;&lt;24 | \</span></span><br><span class="line"><span class="meta">                        (in &amp; 0x0000ff00) &lt;&lt;8  | \</span></span><br><span class="line"><span class="meta">                        (in &amp; 0x00ff0000) &gt;&gt;8  | \</span></span><br><span class="line"><span class="meta">                        (in &amp; 0xff000000) &gt;&gt;24  )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Reverse16(in) ( (in &amp; 0x00ff) &lt;&lt;8  | \</span></span><br><span class="line"><span class="meta">                        (in &amp; 0xff00) &gt;&gt;8   )</span></span><br></pre></td></tr></table></figure>
<p>实际配置的时候采用如下方法：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RX_OWNBYDMA &amp; RX_DAFILTERFAIL</span></span><br><span class="line"><span class="function"><span class="title">rx_mac_desc_ptr</span>[i]-&gt;</span>status = <span class="number">0</span>xC0000000;</span><br><span class="line"><span class="built_in">in</span> = <span class="number">0</span>xC0000000;</span><br><span class="line"><span class="function"><span class="title">rx_mac_desc_ptr</span>[i]-&gt;</span>status = Reverse32(<span class="built_in">in</span>);</span><br></pre></td></tr></table></figure>
<p>RX_OWNBYDMA &amp; RX_DAFILTERFAIL，也就是说，在实际存储中，[31]需要为高，[30]也需要为高，因此是</p>
<p>1100_0000_0000_0000_0000_0000_0000_0000</p>
<p>0xC000_0000</p>
<p>那么为什么需要reverse呢？为什么其他的配置就不需要reverse呢？<strong>不管了</strong>。总之有可能有reverse的需要，按实际硬件来。</p>
<h3 id="WB"><a href="#WB" class="headerlink" title="WB"></a>WB</h3><p>由于tinyriscv只有三级流水线，因此也没有回写(write back，或者说写回)这个阶段，在执行阶段结束后的下一个时钟上升沿就会把数据写回寄存器或者内存。</p>
<p>需要注意的是，在执行阶段，判断如果是内存存储指令(sb、sh、sw)，则向总线发出访问内存请求。而对于内存加载(lb、lh、lw、lbu、lhu)指令是不需要的。因为内存存储指令既需要加载内存数据又需要往内存存储数据。</p>
<p>sb指令：</p>
<blockquote>
<p>LOAD/STORE指令有14条，分别是lb、lbu、lh、lhu、ll、lw、lwl、lwr、sb、sc、sh、sw、swl和swr。</p>
<p>　　以”l”开头的都是加载指令，以”s”开头的都是存储指令，这些指令用于从存储器中读取数据，或者将数据保存在存储器中。</p>
</blockquote>
<p>摘自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/blacksunny/p/7192416.html">MIPS指令介绍2</a></p>
<h2 id="多发射技术"><a href="#多发射技术" class="headerlink" title="多发射技术"></a>多发射技术</h2><p>参见<a target="_blank" rel="noopener" href="http://thebeardsage.com/multiple-issue-processors/">Multiple Issue Processors</a></p>
<blockquote>
<p>Dynamic multiple-issue processors are also known as superscalar processors. An advanced pipelining technique that enables the processor to execute more than one instruction per clock cycle by selecting them during execution.</p>
</blockquote>
<p>动态多发射应该就是超标量。</p>
<h2 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h2><p>乱序执行有点像华罗庚的统筹法</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengxiaocheng/article/details/82468044">乱序执行相关</a></p>
<ol>
<li>洗水壶</li>
<li>烧开水</li>
<li>洗茶壶</li>
<li>洗茶杯</li>
<li>拿茶叶</li>
<li>泡茶</li>
</ol>
<p>先做哪个再做哪个？这就是乱序执行（吗）。</p>
<h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p><strong>CAQA</strong> P473介绍了静态分支预测和动态分支预测的相关内容。</p>
<h2 id="从时钟到控制"><a href="#从时钟到控制" class="headerlink" title="从时钟到控制"></a>从时钟到控制</h2><p>clk信号是一个周期性方波，可以用晶振生成。</p>
<p>如何利用这个周期性方波产生其他波形？例如，如何实现基于clk的计数器？</p>
<h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><p><code>Add R3,R1,B</code>的意思就是R3=R1+B</p>
<p>例如SLT，若小于则置位</p>
<p>SLT R1,R2,R3即R2&lt;R3?R1=0:R1=1;</p>
<h2 id="ISA基础"><a href="#ISA基础" class="headerlink" title="ISA基础"></a>ISA基础</h2><h2 id="分析：流水线"><a href="#分析：流水线" class="headerlink" title="分析：流水线"></a>分析：流水线</h2><p>本分析主要基于<strong>CAQA</strong>的附录C 流水线：基础与中级概念。</p>
<h1 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fuhanghang/article/details/84064530">哈佛结构和冯·诺依曼结构的区别</a>，注意这个人抄的维基百科</p>
<p>冯诺依曼架构可能因为提出的比较早，没有意识到指令数据分开存储的重要性。</p>
<h2 id="冯诺依曼架构"><a href="#冯诺依曼架构" class="headerlink" title="冯诺依曼架构"></a>冯诺依曼架构</h2><p>冯.诺伊曼结构（<strong>von Neumann architecture</strong>），也称<strong>普林斯顿结构</strong>，是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。该结构隐约指导了将储存装置与中央处理器分开的概念，因此依该结构设计出的计算机又称<strong>储存程式型</strong>电脑。</p>
<p>最早的计算机器仅内涵固定用途的程式。现代的某些计算机依然维持这样的设计方式，通常是为了简化或教育目的。例如一个<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/計算器">计算器</a>仅有固定的<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/數學">数学计算</a>程式，它不能拿来当作<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/文書處理">文书处理</a>软件，更不能拿来玩<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/電子遊戲">游戏</a>。若想要改变此机器的程式，你必须更改线路、更改结构甚至重新设计此机器。当然最早的计算机并没有设计的那个可编程化。当时所谓的“重写程式”很可能指的是纸笔设计程式步骤，接着制订工程细节，再施工将机器的电路配线或结构改变。</p>
<p>而储存程式型电脑的概念改变了这一切。借由创造一组<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/指令集架構">指令集结构</a>，并将所谓的<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/計算理論">运算</a>转化成一串<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/程序">程式</a>指令的执行细节，让此机器更有弹性。借着将指令当成一种特别型态的静态资料，一台储存程式型电脑可轻易改变其程式，并在程控下改变其运算内容。<strong>冯·诺伊曼结构</strong>与<strong>储存程式型电脑</strong>是互相通用的名词，其用法将于下述。而<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/哈佛结构">哈佛结构</a>则是一种将程式资料与普通资料分开储存的设计概念,但是它并未完全突破冯.诺伊曼架构。</p>
<p>储存程式型概念也可让程式执行时自我修改程式的运算内容。本概念的设计动机之一就是可让程式自行增加内容或改变程式指令的内存位置，因为早期的设计都要使用者手动修改。但随着索引暂存器与间接位置存取变成硬件结构的必备机制后，本功能就不如以往重要了。而程式自我修改这项特色也被现代程式设计所弃扬，因为它会造成理解与除错的难度，且现代中央处理器的管线与快取机制会让此功能效率降低。</p>
<p>从整体而言，将指令当成资料的概念使得<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/組合語言">组合语言</a>、<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/編譯器">编译器</a>与其他自动编程工具得以实现；可以用这些“自动编程的程式”，以人类较易理解的方式编写程式；从局部来看，强调I/O的机器，例如<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/w/index.php?title=Bitblt&amp;action=edit&amp;redlink=1">Bitblt</a>，想要修改画面上的图样，以往是认为若没有客制化硬件就办不到。但之后显示这些功能可以借由“执行中编译”技术而有效达到。</p>
<p>此结构当然有所缺陷，除了下列将述的<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/冯·诺伊曼结构#.E5.86.AF.C2.B7.E8.AF.BA.E4.BC.8A.E6.9B.BC.E7.93.B6.E9.A0.B8">冯·诺伊曼瓶颈</a>之外，修改程式很可能是非常具伤害性的，无论无意或设计错误。在一个简单的储存程式型电脑上，一个设计不良的程式可能会伤害自己、其他程式甚或是操作系统，导致<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/當機">当机</a>。<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/緩衝區溢位">缓冲区溢位</a>就是一个典型例子。而创造或更改其他程式的能力也导致了<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/惡意軟體">恶意软件</a>的出现。利用缓冲区溢位，一个恶意程式可以覆盖<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/呼叫堆疊">呼叫堆栈</a>（Call stack）并覆写程式码，并且修改其他程式<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/檔案">档案</a>以造成连锁破坏。<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/記憶體保護">内存保护</a>机制及其他形式的<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/存取控制">存取控制</a>可以保护意外或恶意的程式码更动。大多数CPU和GPU是冯诺依曼结构的。</p>
<h2 id="哈佛架构"><a href="#哈佛架构" class="headerlink" title="哈佛架构"></a>哈佛架构</h2><p>哈佛结构(<strong>Harvard architecture</strong>)是一种将程序指令储存和数据储存分开的存储器结构。<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/中央处理器">中央处理器</a>首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作（通常是执行）。程序指令储存和数据储存分开，数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度，如<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/w/index.php?title=Microchip&amp;action=edit&amp;redlink=1">Microchip</a>公司的<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/PIC">PIC</a>16芯片的程序指令是14位宽度，而数据是8位宽度。</p>
<p>哈佛结构的微处理器通常具有较高的执行效率。其程序指令和数据指令分开组织和储存的，执行时可以预先读取下一条指令。</p>
<p>目前使用哈佛结构的<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/中央处理器">中央处理器</a>和<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/微控制器">微控制器</a>有很多，除了上面提到的<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/w/index.php?title=Microchip&amp;action=edit&amp;redlink=1">Microchip</a>公司的<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/PIC">PIC</a>系列芯片，还有<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/Motorola">摩托罗拉公司</a>的MC68系列、<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/w/index.php?title=Zilog&amp;action=edit&amp;redlink=1">Zilog</a>公司的Z8系列、<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/w/index.php?title=ATMEL&amp;action=edit&amp;redlink=1">ATMEL</a>公司的AVR系列和<a target="_blank" rel="noopener" href="http://zh.wikipedia.org/wiki/安谋">安谋</a>公司的ARM9、ARM10和ARM11。大多数DSP是哈佛结构的。</p>
<h2 id="冯诺依曼瓶颈"><a href="#冯诺依曼瓶颈" class="headerlink" title="冯诺依曼瓶颈"></a>冯诺依曼瓶颈</h2><p>将CPU与存储器分开并非十全十美，反而会导致所谓的冯·诺伊曼瓶颈（Von Neumann bottleneck）：在CPU与存储器之间的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/流量">流量</a>（资料传输率）与存储器的容量相比起来相当小，在现代电脑中，流量与CPU的工作效率相比之下非常小，在某些情况下（当CPU需要在巨大的资料上执行一些简单指令时），资料流量就成了整体效率非常严重的限制。CPU将会在资料输入或输出存储器时闲置。由于CPU速度远大于存储器读写速率，因此瓶颈问题越来越严重。</p>
<p>而冯·诺伊曼瓶颈是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/約翰·巴科斯">约翰·巴科斯</a>在1977年ACM<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/图灵奖">图灵奖</a>得奖致词时第一次出现，根据巴科斯所言：</p>
<blockquote>
<p>……确实有一个变更存储设备的方法，比借由冯·诺伊曼瓶颈流通大量资料更为先进。瓶颈这词不仅是对于问题本身资料流量的叙述，更重要地，也是个使我们的思考方法局限在‘一次一字符’模式的智能瓶颈。它使我们怯于思考更广泛的概念。因此编程成为一种项目与详述通过冯·诺伊曼瓶颈的字符资料流，且大部分的问题不在于资料的特征，而是如何找出资料。</p>
</blockquote>
<p>原文如下</p>
<blockquote>
<p>Surely there must be a less primitive way of making big changes in the store than by pushing vast numbers of <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Word_(data_type">words</a>&amp;action=edit&amp;redlink=1) back and forth through the von Neumann bottleneck. Not only is this tube a literal bottleneck for the data traffic of a problem, but, more importantly, it is an intellectual bottleneck that has kept us tied to word-at-a-time thinking instead of encouraging us to think in terms of the larger conceptual units of the task at hand. Thus programming is basically planning and detailing the enormous traffic of words through the von Neumann bottleneck, and much of that traffic concerns not significant data itself, but where to find it.</p>
</blockquote>
<p>在CPU与存储器间的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/快取">缓存</a>存储器抒解了冯·诺伊曼瓶颈的性能问题。另外，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/分支預測">分支预测</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/分支預測器">branch prediction</a>）算法的创建也帮助缓和了此问题。巴科斯在1977年论述的“智能瓶颈”已改变甚多。且巴科斯对于此问题的解决方案并没有造成明显影响。现代的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/函數式編程">函数式编程</a>以及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/物件導向">面向对象</a>编程已较少执行如早期<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Fortran">Fortran</a>一般会“将大量数值从存储器搬入搬出的操作”，但平心而论，这些操作的确占用电脑大部分的执行时间。</p>
<h2 id="内存墙"><a href="#内存墙" class="headerlink" title="内存墙"></a>内存墙</h2><p>有关内存墙的讨论参见<a href="https://njughr.github.io/2021/07/15/memory/">memory</a></p>
<p><strong>缓存性能的10种高级优化方法</strong></p>
<p><strong>8.1</strong> 循环交换</p>
<p>考察下面两段代码即可，非常无脑。第一个在变行，第二个在变列。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">	<span class="attribute">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++)</span><br><span class="line">		<span class="attribute">x</span>[i][j] = <span class="number">2</span> * x[i][j]</span><br></pre></td></tr></table></figure>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++)</span><br><span class="line">	<span class="attribute">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">		<span class="attribute">x</span>[i][j] = <span class="number">2</span> * x[i][j]</span><br></pre></td></tr></table></figure>
<p><strong>Q</strong>: 编译原理好像学过什么反向访问？<code>x=a*b*c</code>是先访问a还是先访问c来着？</p>
<p><strong>A</strong>: 忘了。盲猜先访问c。</p>
<p>该方法可以提高<strong>空间局部性</strong></p>
<p><strong>8.2</strong> 分块</p>
<p>考察矩阵乘法代码，注意该代码具有所谓的<strong>正交访问方式</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="attribute">i</span>=0;i&lt;N;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="attribute">j</span>=0;j&lt;N;j++)&#123;</span><br><span class="line">		<span class="attribute">r</span>=0;</span><br><span class="line">		<span class="keyword">for</span>(<span class="attribute">k</span>=0;k&lt;N;k++)</span><br><span class="line">			r = r + y[i][k]*z[k][j];</span><br><span class="line">		x[i][j]=r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分块的目的是提高<strong>时间局部性</strong>。</p>
<p>为了确保正在访问的元素能放在缓存，对上述代码进行修改，改为计算一个大小为BxB的子矩阵。B称为分块因子。如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="attribute">jj</span>=0;jj&lt;N;jj=jj+B)</span><br><span class="line">	<span class="keyword">for</span>(<span class="attribute">kk</span>=0;kk&lt;N;kk=kk+B)</span><br><span class="line">		<span class="keyword">for</span>(<span class="attribute">i</span>=0;i&lt;N;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="attribute">j</span>=jj;j&lt;min(jj+B,N);j++)</span><br><span class="line">				&#123;<span class="attribute">r</span>=0;</span><br><span class="line">				<span class="keyword">for</span>(<span class="attribute">k</span>=kk;k&lt;min(kk+B,N);k++)</span><br><span class="line">					<span class="attribute">r</span>=r+y[i][k]*z[k][j];</span><br><span class="line">				x[i][j]=x[i][j]+r;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>
<p>基于<strong>CAQA</strong>4.8，对于以矩阵为主要数据结构的程序，缓存分块是必不可少的。</p>
<p>为了保证理解，我们使用5x5矩阵和3x3块重写上述代码</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">for(jj=0;jj&lt;5;jj=jj+3)</span><br><span class="line">	for(kk=0;kk&lt;5;kk=kk+3)</span><br><span class="line">		for(i=0;i&lt;5;i++)</span><br><span class="line">			for(j=jj;j&lt;min(jj+3,5);j++)</span><br><span class="line">				&#123;r=0;</span><br><span class="line">				for(k=kk;k&lt;min(kk+3,5);k++)</span><br><span class="line">					r=r+y<span class="comment">[i]</span><span class="comment">[k]</span>*z<span class="comment">[k]</span><span class="comment">[j]</span>;</span><br><span class="line">				x<span class="comment">[i]</span><span class="comment">[j]</span>=x<span class="comment">[i]</span><span class="comment">[j]</span>+r;</span><br><span class="line">				&#125;</span><br><span class="line">// 一些循环步骤</span><br><span class="line">for(i=0;i&lt;5;i++)</span><br><span class="line">	for(j=0;j&lt;3;j++)</span><br><span class="line">		&#123;r=0;</span><br><span class="line">		for(k=0;k&lt;3;k++)</span><br><span class="line">			r=r+y<span class="comment">[i]</span><span class="comment">[k]</span>*z<span class="comment">[k]</span><span class="comment">[j]</span>;</span><br><span class="line">		x<span class="comment">[i]</span><span class="comment">[j]</span>=x<span class="comment">[i]</span><span class="comment">[j]</span>+r;</span><br><span class="line">		&#125;</span><br><span class="line">for(i=0;i&lt;5;i++)</span><br><span class="line">	for(j=0;j&lt;3;j++)</span><br><span class="line">		&#123;r=0;</span><br><span class="line">		for(k=3;k&lt;5;k++)</span><br><span class="line">			r=r+y<span class="comment">[i]</span><span class="comment">[k]</span>*z<span class="comment">[k]</span><span class="comment">[j]</span>;</span><br><span class="line">		x<span class="comment">[i]</span><span class="comment">[j]</span>=x<span class="comment">[i]</span><span class="comment">[j]</span>+r;</span><br><span class="line">		&#125;</span><br><span class="line">for(i=0;i&lt;5;i++)</span><br><span class="line">	for(j=3;j&lt;5;j++)</span><br><span class="line">		&#123;r=0;</span><br><span class="line">		for(k=0;k&lt;3;k++)</span><br><span class="line">			r=r+y<span class="comment">[i]</span><span class="comment">[k]</span>*z<span class="comment">[k]</span><span class="comment">[j]</span>;</span><br><span class="line">		x<span class="comment">[i]</span><span class="comment">[j]</span>=x<span class="comment">[i]</span><span class="comment">[j]</span>+r;</span><br><span class="line">		&#125;</span><br><span class="line">for(i=0;i&lt;5;i++)</span><br><span class="line">	for(j=3;j&lt;5;j++)</span><br><span class="line">		&#123;r=0;</span><br><span class="line">		for(k=3;k&lt;5;k++)</span><br><span class="line">			r=r+y<span class="comment">[i]</span><span class="comment">[k]</span>*z<span class="comment">[k]</span><span class="comment">[j]</span>;</span><br><span class="line">		x<span class="comment">[i]</span><span class="comment">[j]</span>=x<span class="comment">[i]</span><span class="comment">[j]</span>+r;</span><br><span class="line">		&#125;</span><br><span class="line">// 进一步细化</span><br><span class="line">for(i=0;i&lt;5;i++)&#123;</span><br><span class="line">	// 3x3</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[0]</span>=y<span class="comment">[i]</span><span class="comment">[0]</span>*z<span class="comment">[0]</span><span class="comment">[0]</span>+y<span class="comment">[i]</span><span class="comment">[1]</span>*z<span class="comment">[1]</span><span class="comment">[0]</span>+y<span class="comment">[i]</span><span class="comment">[2]</span>*z<span class="comment">[2]</span><span class="comment">[0]</span>;</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[1]</span>=y<span class="comment">[i]</span><span class="comment">[0]</span>*z<span class="comment">[0]</span><span class="comment">[1]</span>+y<span class="comment">[i]</span><span class="comment">[1]</span>*z<span class="comment">[1]</span><span class="comment">[1]</span>+y<span class="comment">[i]</span><span class="comment">[2]</span>*z<span class="comment">[2]</span><span class="comment">[1]</span>;</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[2]</span>=y<span class="comment">[i]</span><span class="comment">[0]</span>*z<span class="comment">[0]</span><span class="comment">[2]</span>+y<span class="comment">[i]</span><span class="comment">[1]</span>*z<span class="comment">[1]</span><span class="comment">[2]</span>+y<span class="comment">[i]</span><span class="comment">[2]</span>*z<span class="comment">[2]</span><span class="comment">[2]</span>;</span><br><span class="line">	// 3x3</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[0]</span>=y<span class="comment">[i]</span><span class="comment">[3]</span>*z<span class="comment">[3]</span><span class="comment">[0]</span>+y<span class="comment">[i]</span><span class="comment">[4]</span>*z<span class="comment">[4]</span><span class="comment">[0]</span>;</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[1]</span>=y<span class="comment">[i]</span><span class="comment">[3]</span>*z<span class="comment">[3]</span><span class="comment">[1]</span>+y<span class="comment">[i]</span><span class="comment">[4]</span>*z<span class="comment">[4]</span><span class="comment">[1]</span>;</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[2]</span>=y<span class="comment">[i]</span><span class="comment">[3]</span>*z<span class="comment">[3]</span><span class="comment">[2]</span>+y<span class="comment">[i]</span><span class="comment">[4]</span>*z<span class="comment">[4]</span><span class="comment">[2]</span>;</span><br><span class="line">	// 3x2</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[3]</span>=y<span class="comment">[i]</span><span class="comment">[0]</span>*z<span class="comment">[0]</span><span class="comment">[3]</span>+y<span class="comment">[i]</span><span class="comment">[1]</span>*z<span class="comment">[1]</span><span class="comment">[3]</span>+y<span class="comment">[i]</span><span class="comment">[2]</span>*z<span class="comment">[2]</span><span class="comment">[3]</span>;</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[4]</span>=y<span class="comment">[i]</span><span class="comment">[0]</span>*z<span class="comment">[0]</span><span class="comment">[4]</span>+y<span class="comment">[i]</span><span class="comment">[1]</span>*z<span class="comment">[1]</span><span class="comment">[4]</span>+y<span class="comment">[i]</span><span class="comment">[2]</span>*z<span class="comment">[2]</span><span class="comment">[4]</span>;</span><br><span class="line">	// 2x2</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[3]</span>=y<span class="comment">[i]</span><span class="comment">[3]</span>*z<span class="comment">[3]</span><span class="comment">[3]</span>+y<span class="comment">[i]</span><span class="comment">[4]</span>*z<span class="comment">[4]</span><span class="comment">[3]</span>;</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[4]</span>=y<span class="comment">[i]</span><span class="comment">[3]</span>*z<span class="comment">[3]</span><span class="comment">[4]</span>+y<span class="comment">[i]</span><span class="comment">[4]</span>*z<span class="comment">[4]</span><span class="comment">[4]</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 原算法对比</span><br><span class="line">for (i=0;i&lt;5;i++)&#123;</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[0]</span>=y<span class="comment">[i]</span><span class="comment">[0]</span>*z<span class="comment">[0]</span><span class="comment">[0]</span>+y<span class="comment">[i]</span><span class="comment">[1]</span>*z<span class="comment">[1]</span><span class="comment">[0]</span>+y<span class="comment">[i]</span><span class="comment">[2]</span>*z<span class="comment">[2]</span><span class="comment">[0]</span>+y<span class="comment">[i]</span><span class="comment">[3]</span>*z<span class="comment">[3]</span><span class="comment">[0]</span>+y<span class="comment">[i]</span><span class="comment">[4]</span>*z<span class="comment">[4]</span><span class="comment">[0]</span>;</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[1]</span>=y<span class="comment">[i]</span><span class="comment">[0]</span>*z<span class="comment">[0]</span><span class="comment">[1]</span>+y<span class="comment">[i]</span><span class="comment">[1]</span>*z<span class="comment">[1]</span><span class="comment">[1]</span>+y<span class="comment">[i]</span><span class="comment">[2]</span>*z<span class="comment">[2]</span><span class="comment">[1]</span>+y<span class="comment">[i]</span><span class="comment">[3]</span>*z<span class="comment">[3]</span><span class="comment">[1]</span>+y<span class="comment">[i]</span><span class="comment">[4]</span>*z<span class="comment">[4]</span><span class="comment">[1]</span>;</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[2]</span>=y<span class="comment">[i]</span><span class="comment">[0]</span>*z<span class="comment">[0]</span><span class="comment">[2]</span>+y<span class="comment">[i]</span><span class="comment">[1]</span>*z<span class="comment">[1]</span><span class="comment">[2]</span>+y<span class="comment">[i]</span><span class="comment">[2]</span>*z<span class="comment">[2]</span><span class="comment">[2]</span>+y<span class="comment">[i]</span><span class="comment">[3]</span>*z<span class="comment">[3]</span><span class="comment">[2]</span>+y<span class="comment">[i]</span><span class="comment">[4]</span>*z<span class="comment">[4]</span><span class="comment">[2]</span>;</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[3]</span>=y<span class="comment">[i]</span><span class="comment">[0]</span>*z<span class="comment">[0]</span><span class="comment">[3]</span>+y<span class="comment">[i]</span><span class="comment">[1]</span>*z<span class="comment">[1]</span><span class="comment">[3]</span>+y<span class="comment">[i]</span><span class="comment">[2]</span>*z<span class="comment">[2]</span><span class="comment">[3]</span>+y<span class="comment">[i]</span><span class="comment">[3]</span>*z<span class="comment">[3]</span><span class="comment">[3]</span>+y<span class="comment">[i]</span><span class="comment">[4]</span>*z<span class="comment">[4]</span><span class="comment">[3]</span>;</span><br><span class="line">	x<span class="comment">[i]</span><span class="comment">[4]</span>=y<span class="comment">[i]</span><span class="comment">[0]</span>*z<span class="comment">[0]</span><span class="comment">[4]</span>+y<span class="comment">[i]</span><span class="comment">[1]</span>*z<span class="comment">[1]</span><span class="comment">[4]</span>+y<span class="comment">[i]</span><span class="comment">[2]</span>*z<span class="comment">[2]</span><span class="comment">[4]</span>+y<span class="comment">[i]</span><span class="comment">[3]</span>*z<span class="comment">[3]</span><span class="comment">[4]</span>+y<span class="comment">[i]</span><span class="comment">[4]</span>*z<span class="comment">[4]</span><span class="comment">[4]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>z矩阵的划分如下图所示：</p>
<p><img src="/2021/12/17/xPU/Matrix_Z.png" alt="Matrix_Z" style="zoom: 50%;"></p>
<p>明显的，<strong>z矩阵获益于时间局部性</strong>。</p>
<p>同时注意到y矩阵每次只需要访问012或者34，因此<strong>y也获益于空间局部性</strong>。</p>
<p>人脑的运存是真的小…QwQ…不然这点代码也不至于那么难想…</p>
<p><strong>进一步了解矩阵划分</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44026604/article/details/117213368#:~:text=%E7%9F%A9%E9%98%B5%E5%88%92%E5%88%86%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%20%E8%A1%8C%20%E5%88%92%E5%88%86%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%8C%89%E7%85%A7%20%E5%88%97,%E5%88%92%E5%88%86%EF%BC%9B%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%EF%BC%8C%E4%B8%8A%E9%9D%A2%E8%BF%99%E4%B8%A4%E7%A7%8D%E5%88%92%E5%88%86%E5%8F%88%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%98%AF%20%E5%9D%97%20%E5%B8%A6%E7%8A%B6%E5%88%92%E5%88%86%EF%BC%8C%E4%B8%80%E7%A7%8D%E6%98%AF%20%E5%BE%AA%E7%8E%AF%20%E5%B8%A6%E7%8A%B6%E5%88%92%E5%88%86">《并行计算》稠密矩阵运算</a></p>
<p><strong>带状划分</strong></p>
<p>矩阵划分可以按照<strong>行</strong>划分，也可以按照<strong>列</strong>划分；进一步的，上面这两种划分又有两种方式，一种是<strong>块</strong>带状划分，一种是<strong>循环</strong>带状划分</p>
<p><strong>棋盘划分</strong></p>
<p><strong>块棋盘划分【4x4】</strong>和<strong>循环棋盘划分【多x多】</strong></p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p><strong>Q</strong>: 冯诺依曼瓶颈就是内存墙吗？</p>
<p><strong>A</strong>: 不懂。</p>
<p><strong>Q</strong>: 哈佛结构的缺点是？为什么CPU GPU不改用哈佛结构？</p>
<p><strong>A</strong>: 有个初步的想法，哈佛结构由于指令和数据分开存储，灵活性会降低很多。指令安排多大的存储器？数据安排多大的存储器？不同的应用场景很可能需要不同的配置，因此通用性不如冯诺依曼架构。哈佛架构之所以“一采用就比冯诺依曼好”，原因可能还是因为ASIC设计的思路，选择哈佛结构就是选择了一种针对某个应用场景特化的架构，自然比通用架构好。</p>
<p><strong>Q</strong>: 动态多发射就是超标量吗？</p>
<p><strong>A</strong>: 不懂。</p>
<h1 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h1><p>GPU: Graphics Processing Unit</p>
<h2 id="CUDA学习"><a href="#CUDA学习" class="headerlink" title="CUDA学习"></a>CUDA学习</h2><p>1223</p>
<h1 id="NPU"><a href="#NPU" class="headerlink" title="NPU"></a>NPU</h1><p>NPU: Neural Processing Unit. Also known as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/AI_accelerator">AI accelerator</a>.</p>
<h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><p><a target="_blank" rel="noopener" href="https://www.oxfordlearning.com/5-effective-note-taking-methods/">HOW TO TAKE STUDY NOTES: 5 EFFECTIVE NOTE TAKING METHODS</a></p>
<p><a target="_blank" rel="noopener" href="https://www.grammarly.com/blog/note-taking/">7 Note-Taking Tips to Make Studying a Breeze</a></p>
<p>资料详见：D:\Study\Computer_Architecture\</p>
<h1 id="Acknowledgment"><a href="#Acknowledgment" class="headerlink" title="Acknowledgment"></a>Acknowledgment</h1><p>liangkangnan：tinyriscv的作者</p>
<p>ZH：借给我《手把手教你设计CPU——RISC-V处理器》</p>
<p>MLX：提供服务器支持</p>
<hr>
<p><img src="/2021/12/17/xPU/qingming.jpg" alt="清明"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Haoran Geng
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://njughr.github.io/2021/12/17/xPU/" title="xPU学习">https://njughr.github.io/2021/12/17/xPU/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/IC/" rel="tag"># IC</a>
              <a href="/tags/CS/" rel="tag"># CS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/07/news/" rel="prev" title="NEWS">
      <i class="fa fa-chevron-left"></i> NEWS
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/27/sports/" rel="next" title="运动">
      运动 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ABBREVIATIONS"><span class="nav-number">1.</span> <span class="nav-text">ABBREVIATIONS</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU"><span class="nav-number">2.</span> <span class="nav-text">CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RISC-V%E6%94%B6%E9%9B%86"><span class="nav-number">2.1.</span> <span class="nav-text">RISC-V收集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BE%E7%A8%8BCPU%E4%BD%9C%E4%B8%9A"><span class="nav-number">2.2.</span> <span class="nav-text">课程CPU作业</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ibex"><span class="nav-number">2.3.</span> <span class="nav-text">Ibex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99RISC-V%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">2.4.</span> <span class="nav-text">从零开始写RISC-V处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.4.1.</span> <span class="nav-text">if语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#case%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.4.2.</span> <span class="nav-text">case语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#always%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.4.3.</span> <span class="nav-text">always语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">2.4.4.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">2.4.5.</span> <span class="nav-text">硬件架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regs-v"><span class="nav-number">2.4.6.</span> <span class="nav-text">regs.v</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IF"><span class="nav-number">2.4.7.</span> <span class="nav-text">IF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ID"><span class="nav-number">2.4.8.</span> <span class="nav-text">ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EX"><span class="nav-number">2.4.9.</span> <span class="nav-text">EX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MEM"><span class="nav-number">2.4.10.</span> <span class="nav-text">MEM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WB"><span class="nav-number">2.4.11.</span> <span class="nav-text">WB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%8F%91%E5%B0%84%E6%8A%80%E6%9C%AF"><span class="nav-number">2.5.</span> <span class="nav-text">多发射技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-number">2.6.</span> <span class="nav-text">乱序执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B"><span class="nav-number">2.7.</span> <span class="nav-text">分支预测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%97%B6%E9%92%9F%E5%88%B0%E6%8E%A7%E5%88%B6"><span class="nav-number">2.8.</span> <span class="nav-text">从时钟到控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80"><span class="nav-number">2.9.</span> <span class="nav-text">汇编基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ISA%E5%9F%BA%E7%A1%80"><span class="nav-number">2.10.</span> <span class="nav-text">ISA基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="nav-number">2.11.</span> <span class="nav-text">分析：流水线</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CA"><span class="nav-number">3.</span> <span class="nav-text">CA</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9E%B6%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">冯诺依曼架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E4%BD%9B%E6%9E%B6%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">哈佛架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%93%B6%E9%A2%88"><span class="nav-number">3.3.</span> <span class="nav-text">冯诺依曼瓶颈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%A2%99"><span class="nav-number">3.4.</span> <span class="nav-text">内存墙</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q-amp-A"><span class="nav-number">3.5.</span> <span class="nav-text">Q&amp;A</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GPU"><span class="nav-number">4.</span> <span class="nav-text">GPU</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CUDA%E5%AD%A6%E4%B9%A0"><span class="nav-number">4.1.</span> <span class="nav-text">CUDA学习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NPU"><span class="nav-number">5.</span> <span class="nav-text">NPU</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#More"><span class="nav-number">6.</span> <span class="nav-text">More</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Acknowledgment"><span class="nav-number">7.</span> <span class="nav-text">Acknowledgment</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Haoran Geng"
      src="/images/paperboat.jpg">
  <p class="site-author-name" itemprop="name">Haoran Geng</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/njughr" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;njughr" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hrgeng@smail.nju.edu.cn" title="E-Mail → mailto:hrgeng@smail.nju.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1444528490&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Haoran Geng</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script color='105,7,90' opacity='0.6' zIndex='-1' count='100' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  















  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
